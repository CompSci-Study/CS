# 3주차 운영체제

## 운영체제의 역할

1. CPU 스케줄링과 프로세스 관리
2. 메모리 관리
3. 디스크 파일 관리
4. I/O 디바이스 관리

## 운영체제 구조

- 유저 프로그램
- **인터페이스(GUI, CUI)**
- **시스템콜**
- **커널**
    - **드라이버**
    - **파일 시스템 등**
- 하드웨어

### GUI

- 사용자가 전자장치와 상호작용할 수 있도록 하는 사용자 인터페이스의 한 형태
- 단순 명령어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호작용할 수 있다.

### CUI

- 그래픽이 아닌 명령어로 처리하는 인터페이스

### 드라이버

- 하드웨어를 제어하기 위한 소프트웨어

### 시스템콜

- 운영체제가 커널에 접근하기 위한 인터페이스
- **유저 프로그램이** 운영체제의 서비스를 받기 위해 **커널 함수를 호출할 때** 사용
1. 유저 프로그램이 I/O 요청
2. 유저 모드가 시스템콜을 통해 커널 모드로 변환
3. 커널 모드에서 파일 시스템에 접근 (ex. 파일읽기)
4. 유저 모드로 돌아가 유저 프로그램의 로직 수행
- 컴퓨터 자원에 대한 직접 접근을 차단할 수 있다.
- 프로그램을 다른 프로그램으로부터 보호할 수 있다.
- 프로세스 or 스레드에서 운영체제로 요청을 할 때 **시스템콜 인터페이스와 커널을 거침**
    - 프로세스 or 스레드 → **시스템콜** → 커널 → OS
- 장점 : 시스템콜은 하나의 추상화 계층 → 네트워크 통신이나 데이터베이스와 같은 낮은 단계의 영역 처리에 대한 부분을 많이 신경 쓰지 않고 프로그램을 구현할 수 있다.

### modebit

- 유저 모드와 커널 모드를 구분하는 플래그 변수
- 0 : 커널 모드
- 1 : 유저 모드

### 커널

- 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할을 한다.

# 컴퓨터의 요소

- CPU
- DMA 컨트롤러
- 메모리
- 타이머
- 디바이스 컨트롤러 등으로 이루어짐

## CPU Central Processing Unit

- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있다.
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해성해서 실행한다.
- 관리자 역할인 운영체제의 커널이 프로그램을 메모리에 올려 프로세스로 만들면 CPU가 처리한다.

### 제어장치 CU, Control Unit

- 프로세스 조작을 지시하는 CPU의 한 부품
- 입출력장치간 통신 제어
- 명령어 읽고 해석
- 데이터 처리를 위한 순서 결정

### 레지스터

- CPU 안에 있는 매우 빠른 임시기억장치
- CPU와 직접연결되어 있어 메모리보다 연산속도가 수십~수백배까지 빠르다.
- CPU 자체적으로 데이터를 저장할 방법이 없기 때문에 레지스터를 거쳐 데이터를 전달한다.

### 산술논리연산장치 ALU, Arithmetic Logic Unit

- 덧셈, 뺄셈 등 산술 연산, 배타적 논리합(XOR), 논리곱 같은 논리 연산을 계산하는 디지털 회로

### CPU 연산 처리

1. 제어장치가 **메모리에 계산할 값 로드 + 레지스터에도 로드**
2. 제어장치가 **레지스터에 있는 값을 계산**하라고 **산술논리연산장치에 명령**
3. 제어장치가 계산된 값을 **레지스터에서 메모리로 저장**

### 인터럽트

- 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것
- 인터럽트가 발생되면 인터럽트 핸들러 함수가 모여있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행됨
- 인터럽트 간에는 우선순위가 있고 우선순위에 따라 실행된다.
- 하드웨어 인터럽트 : 키보드 연결, 마우스 연결 등의 IO 디바이스에서 발생하는 인터럽트
- 소프트웨어 인터럽트 : 트랩(trap)이라고도 하며, 프로세스 오류 등으로 프로세스가 시스템콜을 호출할 때 발동한다.

### 메모리

- 데이터, 상태, 명령어 등을 기록하는 장치

### 타이머

- 작업이 끝나는 시간 제한하는 역할

### 디바이스 컨트롤러

- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU
- 로컬 버퍼라는 작은 메모리가 각 디바이스에서 임시로 데이터를 저장함

# 메모리

## 메모리 계층

- 레지스터 : CPU안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음
- 캐시 : L1, L2 캐시, 휘발성, 속도 빠름, 기억용량이 적음
- 주기억장치 : RAM, 휘발성, 속도 보통, 기억용량 보통
- 보조기억장치 : HDD, SDD, 비휘발성, 속도 낮음, 기억 용량 많음

## 캐시 cache

- 데이터를 미리 복사해 놓는 임시 저장소
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
- ex)메모리와 CPU 사이의 속도차이를 해결하기 위해 레지스터 계층으로 해결
- ex)

## 가상메모리 virtual memory

- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것
- 가상 주소와 실제 메모리상의 실제 주소가 매핑되어 있고, 프로세스의 주소 정보가 들어있는 페이지 테이블로 관리된다.
- 속도향상을 위해 TLB을 사용한다.

### TLB

- 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시

## 프로세스 vs 쓰레드 차이

```
프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다.

쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.
```

## 멀티 프로세스

```
멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만
멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.
```

## 멀티 쓰레드

```
멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만
하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다.
```

## 데드락이란? (교착상태)

```
둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.
예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 됩니다.
```

## 데드락 발생 원인

데드락의 4가지 조건

1. 비선점 (Nonpreemptive) : 다른 프로세스의 자원을 뺏을 수 없음.
2. 순환 대기 (Circular wait) : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 관계가 순환적 구조.
3. 점유 대기 (Hold & Wait) : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구.
4. 상호 배제(Mutual Exclusion) : 한 번에 한 프로세스만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우.

## Critical Section(임계영역)에 대해 설명해주세요.

```
임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다.임계 영역 문제를 해결하기 위해서는 아래의 3가지 조건을 충족해야 합니다.
```

1. 상호 배제(Mutual exclution) - 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
2. 진행(Progress) - 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈지 결정 해주어야 한다.
3. 한정 대기(Bounded waiting) - 다른 프로세스의 기아를 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 임계 영역에 들어갈 때 제한을 두어야 한다.

## 페이지 교체 알고리즘에 대해 설명해주세요.

- 페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이징 부재시) 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법을 페이지 교체 알고리즘이라고 합니다.
- **FIFO(first in first out)**
    - 가장 간단한 알고리즘으로, 메모리에 올라온 지 가장 오래된 페이지를 교체합니다. 간단하고, 초기화 코드에 대해 적절한 방법이며, 페이지가 올라온 순서를 큐에 저장합니다.

- **최적(Optimal) 페이지 교체**
    - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘입니다. 최적 페이지 교체는 선행 조건이 있는데, 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다는 것입니다. 이 조건은 실제 활용에선 알 방법이 없기 때문에 최적 알고리즘은 구현이 불가능한 알고리즘입니다. 때문에 연구를 목적으로 주로 사용됩니다.

- **LRU(least-recently-used)**
    - 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘입니다. OPT 알고리즘의 방식과 비슷한 효과를 낼 수 있는 방법이며, OPT 알고리즘보다 페이지 교체 횟수가 높지만 FIFO 알고리즘 보다 효율적입니다.

- **LFU(least-frequently-used)**
    - 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘입니다. 만약 대상인 페이지가 여러 개 일 경우, LRU 알고리즘을 따라 가장 오래 사용되지 않은 페이지로 교체합니다.

- **MFU(most-frequently-used)**
    - LFU 알고리즘과 반대로, 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘입니다.

- **LFU와 MFU는 실제 사용에 잘 쓰이지 않는다.**
    - 구현에 상당한 비용이 들고,
    - 최적 페이지 교체 정책을 (LRU 만큼) 제대로 유사하게 구현해내지 못하기 때문이다.