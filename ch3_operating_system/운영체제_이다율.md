## 운영체제 컴퓨터

운영체제 : 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스, 한정된 메모리나 시스템 자원을 효율적으로 분배 

### 운영체제 역할 구조

> 운영 체제의 역할

   1. CPU 스케쥴링과 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리 
   2. 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼마만큼 할당할지 관리
   3. 디스크 파일 관리 : 어떤 방법으로 보관할 지 관리 
   4. I/O 디바이스 관리 : I/O 디바이스와 컴퓨터 간에 데이터를 주고 받는 것 

> 운영 체제의 구조
    
   유저 프로그램 >> 인터페이스 (GUI, CUI) >> 시스템 콜 >> 커널 [ 드라이버, 파일 시스템 ] >> 하드웨어  
   
   - 시스템콜 : 운영체제가 커널에 접근하기 위한 인터페이스, 커널 함수를 호출할 때  사용, 추상화 계층
      
      장점 ) 직접 접근 차단, 보호,
      
      - modebit : 시스템 콜이 작동될 때 modebit을 참고해서 유저 모드와 커널 모드를 구분, 1, 0의 값을 가지는 플래그 변수

### 컴퓨터의 요소

> CPU 

: 컴퓨터의 핵심 처리 장치로, 메모리에 있는 명령어를 해석하고 실행. 운영체제의 커널이 프로그램을 메모리에 올려 프로세스를 만들면 CPU가 이를 처리.

> DMA 컨트롤러

: IO 디바이스가 메모리에 직접 접근할 수 있도록 함, CPU 부하를 막고, CPU와 DMA 컨트롤러가 동시에 작업하는 것을 방지

> 메모리

: 전자회로에서 데이터나 상태, 명령어 등을 저장하고 관리, CPU는 계산, 메모리는 기억 담당

> 타이머 

: CPU 및 시스템의 시간을 관리하여 작업을 제어.

> 디바이스 컨트롤러 

: CPU와 IO 디바이스 간의 작업을 효율적으로 처리


## 메모리

### 메모리 계층

`레지스터` >> `캐시`( L1, L2 캐시 ) >>`메모리` ( RAM ) / 주기억장치 >> `저장장치`( HDD, SSD ) / 보조기억장치 

계층 위로 올라갈수록 가격을 비싸고, 용량은 작아지고 속도는 빨라짐.

계층이 있는 이유 : 경제성, 캐시 

> 캐시

 : 임시 데이터 저장소, 속도 차이에 따른 병목 현상을 줄이기 위한 메모리 →  시간 지연 해결, 재계산 시간 절약
    
   속도 차이를 해결하기 위한 계층: 캐싱 계층 
   
   - 지역성의 원리
      - 시간 지역성 : 최근 사용한 데이터에 다시 접근
      - 공간 지역성 : 최근 접근한 데이터를 이루는 공간이나 그 가까운 공간에 접근

> 캐시히트와 캐시미스
   
   캐시히트 : **캐시**에서 원하는 데이터 찾음, CPU 내부 기반 작동 → 빠름 
   
   캐시미스 : **주 메모리**로 가서 데이터 찾음, 시스템 버스 → 느림 
   
   - 캐시매핑 : 캐시가 히트되기 위해 매핑하는 방법
   - 웹 브라우저의 캐시
      - 쿠키
      - 로컬 스토리지
      - 세션 스토리지
      
      |  | 쿠키 | 로컬 스토리지 | 세션 스토리지  |
      | --- | --- | --- | --- |
      | 특성 | httponly 옵션 걸기 |  | 탭을 닫을 때 삭제  |
      | 저장형태 | 키 - 값  | 키 - 값  | 키 - 값  |
      | 만료기한 | O ( 서버에서 설정) | X | X |
      | 수정 |  | 클라이언트에만 수정가능 | 클라이언트에만 수정가능 |
   - 데이터베이스의 캐싱 계층 : 레디스
    

### 메모리 관리

> 가상 메모리

 : 메모리 관리 기법 중 하나, 메모리 자원 추상화, TLB(주소변환을 위한 캐시)로 속도 향상
   - 페이지 폴트 : 실제 메모리인 RAM에 현재 없는 데이터나 코드에 접근할 경우 페이지 폴드 발생
   - 스와핑 : 페이지 폴트 발생 시, 하드 디스크의 일부분을 메모리처럼 불러와 사용

> 스레싱

 : 페이지 폴트율이 높은 것, 스와핑이 많이 일어나 성능 저하 유발
    
   [ 해결방안 ] 메모리 확장, SSD 교체, 작업세트, PFF(Page Fault Frequency). 
   <br>
   [ 운영체제 해결 방안 ]     
   - 작업세트 : 지역성 통해 페이지 집합을 만들어 미리 메모리에 로드 → 탐색 비용 절약, 스와핑 감소
   - PFF : 페이지 폴트 빈도가 상한선 도달 → 프레임 확장, 하한선 도달 → 프레임 축소

> 메모리 할당

   - 연속 할당 : 메모리에 연속적으로 공간 할당
      - 고정 분할 방식 : 메모리를 미리 나누어 관리 → 융통성 없음, 내부 단편화( 나눈 크기보다 프로그램이 작음 )
      - 가변 분할 방식 : 크기에 맞게 동적으로 나눠 사용 → 외부 단편화 발생 ( 나는 크기보다 프로그램이 큼 )
   - 불연속 할당 : 메모리를 나눠 효율적 사용
      - 페이징 : 동일한 크기의 페이지 단위로 나눔, -) 주소 변환 복잡
      - 세그멘테이션 : 의미 단위인 세그먼트로 나눔, + ) 공유와 보안에 좋음, - ) 홀 크기 불균일
      - 페이지드 세그멘테이션 : 세그멘테이션 + 페이징

> 페이지 교체 알고리즘

 : 스와핑 최소화를 위한 기법
   - 오프라인 알고리즘
   - FIFO : FIRST IN FIRST OUT
   - LRU : LEAST RECENTLY USED, 해시 테이블과 이중 연결 리스트 사용해서 구현
      - NUR : NOT USED RECENTLY
   - LFU : LEAST FREQUENTLY USED, 가장 참조 횟수가 적은 페이지 교체

## 프로세스와 스레드

**`프로세스`** : 실행되고 있는 프로그램, 작업(task)와 같은 의미, 메모리에 올라가 인스턴스화 됨 

**`스레드`** : 작업의 흐름 

### 프로세스와 컴파일 과정

컴파일 과정 : 소스 코드 파일 → 전처리 → 컴파일러 → 어셈블리어 → 어셈블러 → 목적 코드 → 링커 

- 전처리 : 주석 제거, 헤더파일 병합, 매크로 치환
- 컴파일러 : 오류 처리, 코드 최적화 작업하여 어셈블리어로 변환
- 어셈블러 : 목적코드로 변환
- 링커 : 목적 코드를 결합하여 실행 파일 생성

### 프로세스의 상태

- 생성 상태 : PCB 할당
- 대기 상태 : 메모리 공간 충분 → 할당, 부족 → 대기, CPU 소유권이 넘어오기를 기다리는 상태
- 대기 중단 상태 : 메모리 부족으로 일시중단
- 실행 상태 : CPU 소유권과 메모리 할당
- 중단 상태 : 프로세스 차단, I/O 디바이스에 의한 인터럽트로 많이 발생
- 일시중단 상태 : 메모리 부족으로 일시 중단 상태
- 종료 상태 : 프로세스 실행이 종료된 상태

### 프로세스의 메모리 구조

- 스택과 힙 : 스택과 힙은 **`동적할당`**(런타임 단계에서 메모리 할당)가능, 스택은 특정정보를 계속 저장, 힙은 동적으로 할당되는 변수를 담음
- 데이터와 영역관리 코드 영역 : **`정적할당`**되는 영역, 컴파일 단계에서 메모리 할당

### PCB

프로세스에 대한 메타데이터를 저장한 ‘데이터’

프로그램 실행 → 프로세스 생성 → 메모리 할당 → PCB에 저장, 관리 

- PCB 구조 : 프로세스 스케줄링 상태, 카운터, 레지스터 등으로 구성
- 컨텍스트 스위칭 : PCB 기반으로 CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것

### 멀티 프로세싱

`멀티 프로세싱` : 여러 개의 프로세서가 작업을 병렬처리하는 것 

장점 ) 프로세스 일부에 문제가 발생해도 다른 프로세스를 이용해 처리 → 신뢰성 높음 

- IPC ( Inter Process Communication ) : 프로세스끼리 데이터를 주고받고 공유 데이터 관리, 스레드보다는 속도가 떨어짐
<br>
   ex. 파이프, 공유메모리, 메세지큐 

### 스레드와 멀티스레딩

- `스레드` : 프로세스의 실행 가능한 가장 작은 단위
- `멀티 스레딩` : 프로세스 내 작업을 멀티 스레드로 처리
   
   장점 ) 서로 자원 공유 → 효율성 높음, 한 스레드가 중단되어도 다른 스레드로 처리, 동시성 장점   
   단점 ) 한 스레드에 문제 있음 → 다른 스레드에 영향 → 프로세스에 영향 
    

### 공유 자원과 임계 영역

- 공유 자원 : 시스템 안에서 각 프로세스, 스레드가 함께 접근 할 수 있는 모니터, 프린트, 메모리, 파일, 데이터 등의 자원이나 변수
   
   **`경쟁상태` : 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황** 
    
- 임계 영역 : 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
   
   해결 방법 : 뮤텍스, 세마포어, 모니터로 크게 세가지, 잠금 메커니즘이 기본 베이스 
   
   조건 : 상호 배제, 한정 대기, 융통성 
   
   - 뮤텍스 : 잠금기반 상호배제
   - 세마포어 : 공유 자원에 대한 접근 처리, 신호기반 상호배제, 명시적으로 구현
   - 모니터 : 자동 상호배제
    

### 교착상태

교착상태 : 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태 

- 교착상태의 원인 : 상호 배제, 점유 대기, 비선점, 환형 대기
- 교착상태의 해결 방법 : ‘은행원 알고리즘’으로 자원할당 가능 여부 파악

## CPU 스케쥴링 알고리즘

CPU 스케줄러 : 알고리즘에 따라 프로세스에서 해야 할 일을 스레드 단위로 CPU에 할당, **CPU 이용률 높게, 프로세스 적게, 시간 최소화**

### 비선점형 방식

비선점형 방식 : 프로세스가 스스로 CPU 소유권 포기, 컨텍스트 스위칭으로 인한 부하가 적음

- FCFS : 가장 먼저 온 것을 가장 먼저 처리
- SJF : 기존 프로세스를 모두 수행하고, 실행시간이 가장 짧은 프로세스를 가장 먼저 처리
- 우선순위 : 오래된 작업일수록 우선순위를 높혀 처리

### 선점형 방식

선점형 방식 : 프로세스를 알고리즘에 의해 중단, 강제로 다른 프로세스에 CPU 할당 

- 라운드 로빈 : 프로세스는 동일한 할당 시간 부여, 시간 내 끝나지 않을 시 다시 준비 큐에 들어감
- SRF : 수행하던 프로세스 중지, 시간이 더 짧은 프로세스 수행
- 다단계 큐 : 모든 알고리즘 사용. 스케쥴링 부담이 적으나 유연성이 떨어짐