# CS스터디 3회차 - OS

날짜: 2025년 1월 16일

# 1. OS와 컴퓨터

### OS의 역할

- **CPU 스케줄링, 프로세스 생성/관리/삭제**
- **메모리 관리**: 어떤 프로세스에 메모리를 얼만큼 할당할지 관리.
- **디스크 파일 관리**: 파일 시스템을 통해 데이터를 저장, 관리.
- **I/O 디바이스 관리**: 마우스, 키보드 등의 장치와 데이터를 주고받는 것을 관리.

### OS의 구조

- **시스템 콜:** 유저 프로그램이 커널 함수를 호출할 때 사용하는 인터페이스.
    
    이를 통해 컴퓨터 자원에 대한 직접 접근을 차단하고 프로그램을 보호할 수 있다.
    
- **커널:** 하드웨어와 어플리케이션 간의 중개자 역할을 하는 OS의 핵심 요소.

### 컴퓨터의 요소

- **CPU (= ALU + CU + 레지스터)** (일꾼): 메모리에 올라온 프로세스를 실행하는 중앙 처리 장치.
- CPU의 연산처리 과정
    1. CU가 계산할 값을 메모리와 레지스터에 로드
    2. 레지스터에 있는 값을 계산하라고 CU가 ALU에 명령
    3. 레지스터에 있는 계산이 완료된 값을 CU가 메모리에 저장
- **DMA 컨트롤러** (보조 일꾼): CPU를 거치지 않고 메모리와 장치 간 데이터 전송을 관리.
- **메모리** (작업장): 데이터를 임시 저장하고 프로그램이 프로세스로 “인스턴스화” 되는 작업 공간.
- **타이머**: “무한 루프 방지”를 위해, 프로그램에 시간 제한을 거는 역할.
- **디바이스 컨트롤러**: I/O 디바이스들의 작은 CPU.

# 2. 메모리

### 메모리 계층

- **레지스터**: CPU 내부의 매우 빠른 임시 메모리. CPU는 레지스터를 통해 데이터를 전달.
- **캐시**: 자주 사용되는 데이터를 미리 복사해 접근속도를 높이고, 메모리 계층 간 속도 차이로 인한 “병목현상”을 줄이는 임시 메모리.
- **주기억장치(RAM)**: 실행 중인 프로그램과 데이터를 저장하는 주요 메모리.
- **보조기억장치(HDD, SSD)**: 데이터를 영구적으로 저장하는 디스크나 SSD.

### 웹 브라우저의 캐시

|  | **쿠키** | **로컬 스토리지** | **세션 스토리지** |
| --- | --- | --- | --- |
| **만료 기한** | O (설정 가능) | 영구적 | 브라우저 탭 닫을 때까지 |
| **크기 제한** | 4KB | 5MB | 5MB |
| **데이터 공유범위** | **서버-클라이언트 간**
(서버와 데이터 동기화에 사용) | **동일 브라우저** **내** | **동일 탭 내** |
| **활용 예시** | - 서버 세션 ID 저장
- 사용자 행동 추적 | - 사용자 환경 설정 저장
- 오프라인 데이터 저장 | - 폼 데이터의 임시 저장
- 같은 탭에서 페이지 간 상태 유지 |

### 메모리 관리

- **가상 메모리**: 실제 메모리보다 크게 보이게 만드는 기술. MMU가 페이지 테이블을 이용해 가상 주소를 실제 주소로 변환해준다.
- page fault가 일어난 경우 처리과정
    1. 프로세스가 시스템 콜을 호출하는 trap이 발생한다.
    2. **swapping:** OS는 “페이지 교환 알고리즘(LRU, LFU 등)”을 기반으로, 해당 프레임을 메모리에 가져온다.
    3. “페이지 테이블”을 갱신한 후, 명령어를 다시 시작한다.
- **thrashing**: 과도한 swapping으로 성능이 급격히 저하되는 현상. 메모리를 늘리거나 working set, PFF 등으로 해결.
- **메모리 할당**: 연속 할당 (고정 분할 할당, 가변 분할 할당) vs 불연속 할당 (paging, segmentation, paged segmentation)

# 3. 프로세스와 스레드

- **process**: 프로그램이 메모리에 올라가 “인스턴스화”된 것.
- **thread**: 프로세스 내 “작업의 흐름”으로서, 실행 가능한 가장 작은 단위.

### 프로세스와 컴파일 과정

- **전처리**: 코드 내 주석을 제거하고, 매크로와 헤더 파일을 처리.
- **컴파일러**: 오류 처리 및 코드 최적화 작업을 하고, 고수준 언어 코드를 어셈블리어로 변환.
- **어셈블러**: 어셈블리어를 목적 코드로 변환.
- **링커**: 라이브러리와 목적 코드를 결합해 실행 가능한 파일을 생성. (자바는 없음)

|  | **C 언어** | Java |
| --- | --- | --- |
| **소스코드 파일 (컴파일 전)** | .cpp | .java |
| **실행 파일 (컴파일 후의 바이너리 데이터)** | .exe, .out | .class |
| **링커 유무** | O | X |
| **실행 장소** | OS 위 | OS 위에서 동작하는 **JVM** 위 |

### 프로세스의 상태

- **생성**: 새로운 프로세스를 초기화. (PCB 할당)
- **대기**: 메모리를 할당받기 전, CPU 소유권을 기다리는 상태.
- **대기 중단**: 메모리 부족으로 대기가 중단된 상태.
- **실행**: CPU 소유권과 메모리를 할당받아 instruction(프로세스 내 명령어)를 수행중인 상태.
- **중단**: 프로세스가 강제로 종료된 상태. (예: I/O 디바이스에 의한 인터럽트)
- **일시 중단**: 메모리 부족으로 실행이 일시 중단된 상태.
- **종료**: 프로세스가 완료되어 CPU 소유권과 메모리를 두고가는 상태.

### 프로세스의 메모리 할당구조

|  | **저장되는 것** | **할당/소멸** |
| --- | --- | --- |
| **Stack** | local 변수, 매개변수 | “함수 호출시” 할당, 함수 완료시 소멸 |
| **Heap** | 동적 할당 변수 | **new** 연산으로 생성, 필요 없어지면 **GC**가 삭제 |
| **BSS segment** | “초기화되지 않은” global, static 변수 |  |
| **Data segment** | “초기화된” global, static 변수 |  |
| **Code segment** | 실행 명령 (함수, 제어문, 상수)
→ CPU가 하나씩 처리 |  |
- Stack, Heap 영역은 “런타임시” 동적 할당
- 데이터, 코드 영역은 “컴파일시” 정적 할당 → “프로세스 생성시”(=프로그램 시작시) 할당되고, 종료시 소멸

### PCB

- 프로세스에 대한 중요 정보를 담은 “메타 데이터”. 프로세스 생성시 OS가 PCB를 생성한다.
- **구조**: 프로세스의 상태와 카운터, CPU 레지스터 등이 포함.
- **컨텍스트 스위칭**: PCB를 기반으로 프로세스 상태를 저장하고 로드하는 과정.

### 멀티 프로세싱

- 여러 프로세스를 이용해 여러 일을 병렬로 동시에 처리하는 방식.
- **웹 브라우저**: 여러 프로세스(브라우저, 렌더러, 플러그인, GPU 등)를 사용해 성능과 안정성을 향상.
- **IPC**: 프로세스 간 데이터를 교환하는 방법. (예: 클라이언트-서버)
- **IPC의 종류**: 공유 메모리, 파일, 소켓, 파이프, 메시지 큐 등 다양한 방식 존재.

### 멀티 스레딩

- 한 프로세스 내에서 여러 실행 흐름을 병렬 처리하는 방식. (예: 웹 브라우저의 렌더러 프로세스를 구성하는 여러 스레드)
- **장점:** 힙,데이터,코드 영역을 공유하기 때문에, 멀티 프로세싱보다 효율성과 동시성이 높다.
- **단점:** 한 스레드에 문제가 생기면 다른 스레드에도 영향을 줄수있다.

### 임계영역

- 둘 이상의 프로세스나 스레드가 공유자원에 접근하면 결과가 달라질 수 있는 코드 영역
- **해결 조건:** 상호 배제, 한정 대기, 융통성
- **mutex:** 공유자원에 대해 “lock/unlock”으로 접근을 처리하는 객체.
- **semaphore:** 일반화된 mutex로서, “wait/signal”로 접근을 처리하는 객체.
- **monitor:** 공유자원에 대한 인터페이스만 제공하고, 모니터 큐로 접근 작업들을 순차 처리하는 객체.

### 데드락

- **개념**: 여러 프로세스가 서로 자원을 기다리며 멈추는 상태.
- **원인**: 상호 배제, 점유 대기, 비선점, 순환 대기 조건 충족.
- **해결방법**: 예방, 회피, 탐지 및 복구 기법.

# 4. CPU 스케줄링 알고리즘

- **목표**: 효율적인 CPU 사용, 대기 시간 최소화, 공정성 유지.
- **비선점형 방식**: 실행 중인 프로세스를 끝날 때까지 유지 (예: FCFS, SJF).
- **선점형 방식**: 우선순위에 따라 실행 중인 프로세스를 중단 가능 (예: Round Robin, SRF, 다단계 큐).