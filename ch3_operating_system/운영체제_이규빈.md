# CS스터디 3회차 - OS

날짜: 2025년 1월 16일

# 1. OS와 컴퓨터

### OS의 역할

- **CPU 스케줄링, 프로세스 생성/관리/삭제**
- **메모리 관리**: 어떤 프로세스에 메모리를 얼만큼 할당할지 관리.
- **디스크 파일 관리**: 파일 시스템을 통해 데이터를 저장, 관리.
- **I/O 디바이스 관리**: 마우스, 키보드 등의 장치와 데이터를 주고받는 것을 관리.

### OS의 구조

- **시스템 콜:** 유저 프로그램이 커널 함수를 호출할 때 사용하는 인터페이스.
    
    이를 통해 컴퓨터 자원에 대한 직접 접근을 차단하고 프로그램을 보호할 수 있다.
    
- **커널:** 하드웨어와 어플리케이션 간의 중개자 역할을 하는 OS의 핵심 요소. 드라이버나 파일 시스템 등이 포함된다.

### 컴퓨터의 요소

- **CPU (= ALU + 제어장치 + 레지스터)**: 메모리에 올라온 프로세스를 실행하는 중앙 처리 장치.
- CPU의 연산처리 과정
    1. 계산할 값을 제어장치가 메모리와 레지스터에 로드
    2. 레지스터에 있는 값을 계산하라고 제어장치가 ALU에 명령
    3. 레지스터에 있는 계산이 완료된 값을 제어장치가 메모리에 저장
- **DMA 컨트롤러**: CPU를 거치지 않고 메모리와 장치 간 데이터 전송을 관리.
- **메모리**: 데이터를 임시 저장하고 프로그램이 프로세스로 “인스턴스화” 되는 작업 공간.
- **타이머**: “무한 루프 방지”를 위해, 프로그램에 시간 제한을 거는 역할.
- **디바이스 컨트롤러**: I/O 디바이스들의 작은 CPU.

# 2. 메모리

### 메모리 계층

- **레지스터**: CPU 내부의 매우 빠른 임시 메모리. CPU는 레지스터를 통해 데이터를 전달.
- **캐시**: 자주 사용되는 데이터를 미리 복사해 접근속도를 높이고, 메모리 계층 간 속도 차이로 인한 “병목현상”을 줄이는 임시 메모리.
- **주기억장치(RAM)**: 실행 중인 프로그램과 데이터를 저장하는 주요 메모리.
- **보조기억장치(HDD, SSD)**: 데이터를 영구적으로 저장하는 디스크.
- 아래로 갈수록 CPU에서 멀어지며, 속도는 느려지지만 용량이 커진다.

### 웹 브라우저의 캐시

모두 데이터를 캐싱하는 키-값 저장소

|  | **쿠키** | **로컬 스토리지** | **세션 스토리지** |
| --- | --- | --- | --- |
| **만료 기한** | O (서버가 설정 가능) | 영구적 | 브라우저 탭 닫을 때까지 |
| **크기 제한** | 4KB | 5MB | 5MB |
| **데이터 공유범위** | **서버-클라이언트 간**
(서버와 데이터 동기화에 사용) | **동일 브라우저** **내** | **동일 탭 내** |
| **활용 예시** | - 서버 세션 ID 저장<br>- 사용자 행동 추적 | - 사용자 환경 설정 저장<br>- 오프라인 데이터 저장 | - 폼 데이터의 임시 저장<br>- 같은 탭에서 페이지 간 상태 유지 |

### [추가] 세션 기반 인증 vs 토큰 기반 인증

|  | **세션 기반 인증** | **토큰 기반 인증** |
| --- | --- | --- |
| **개념** | - 서버가 사용자 인증 정보를 서버 메모리에 저장하고 세션 ID를 클라이언트에 전달<br>- 클라이언트는 쿠키로 세션 ID를 저장하고 요청 시마다 전송 | - 클라이언트가 인증 시 서버에서 생성된 토큰(JWT 등)을 전달받아 저장<br>- 클라이언트는 요청 시마다 토큰을 포함해 전송 |
| **구현 방식** | 1. 사용자가 로그인 정보를 서버에 전송<br>2. 서버는 세션 생성 후 세션 ID를 클라이언트에 전달<br>3. 클라이언트는 쿠키에 세션 ID 저장<br>4. 요청마다 세션 ID를 전송하고 서버는 세션 정보로 사용자 인증 | 1. 사용자가 로그인 정보를 서버에 전송<br>2. 서버는 인증 후 토큰 생성 (JWT 등)하여 클라이언트에 전달<br>3. 클라이언트는 토큰을 로컬스토리지나 쿠키에 저장<br>4. 요청 시 토큰을 헤더(Authorization)로 전송 |
| **장점** | - 간단한 구현<br>- 서버에서 세션 정보 관리로 높은 보안성<br>- 세션 만료 및 로그아웃 처리가 쉬움 | - 확장성이 높음 (분산 서버 환경에 적합)<br>- 클라이언트에서 토큰 관리로 서버 부하 감소<br>- 토큰 내 정보로 인증 요청 처리 속도 빠름 |
| **단점** | - 서버 메모리를 사용하므로 확장성 낮음<br>- 많은 사용자 처리 시 서버 부담 증가<br>- 분산 서버 환경에서 세션 공유 필요 | - 토큰 탈취 시 보안 취약 (유효기간이 만료될 때까지 악용 가능)<br>- 로그아웃 처리가 복잡<br>- 토큰 크기 커질 경우 네트워크 부하 발생 |
| **적합한 환경** | - 소규모 또는 단일 서버 환경<br>- 사용자 수가 적고 보안이 중요한 경우 | - 대규모 시스템 또는 분산 서버 환경<br>- RESTful API와 모바일 클라이언트 사용 사례 |

### 메모리 관리

- **가상 메모리**: 실제 메모리보다 크게 보이게 만드는 기술. MMU가 페이지 테이블을 이용해 가상 주소를 실제 주소로 변환해준다.
- page fault가 일어난 경우 처리과정
    1. 프로세스가 시스템 콜을 호출하는 trap이 발생한다.
    2. **swapping:** OS는 “페이지 교체 알고리즘(LRU, LFU 등)”을 기반으로 해당하는 프레임과 사용하지 않는 메모리의 페이지를 교체한다.
    3. “페이지 테이블”을 갱신한 후, 명령어를 다시 시작한다.
- **thrashing**: 과도한 swapping으로 CPU 성능이 급격히 저하되는 현상. → 메모리를 늘리거나, working set를 미리 로드하거나, PFF 방법 등으로 해결.
- **페이지 교체 알고리즘**
    - FIFO(First In First Out): “먼저 들어온” 페이지를 교체
    - LRU(Least Resently Used): “참조된지 가장 오래된” 페이지를 교체
    - NUR(Not Used Resently = clock 알고리즘)
    - LFU(Least Frequently Used): “가장 적게 참조된” 페이지를 교체
- **메모리 할당**: 연속 할당 (고정 분할 할당, 가변 분할 할당) vs 불연속 할당 (paging, segmentation, paged segmentation)

# 3. 프로세스와 스레드

- **process**: 프로그램이 메모리에 올라가 “인스턴스화”된 것.
- **thread**: 프로세스 내 “작업의 흐름”으로서, 실행 가능한 가장 작은 단위.

### 프로세스와 컴파일 과정

- **전처리**: 코드 내 주석을 제거하고, 매크로와 헤더 파일을 처리.
- **컴파일러**: 오류 처리 및 코드 최적화 작업을 하고, 고수준 언어 코드를 어셈블리어로 변환.
- **어셈블러**: 어셈블리어를 목적 코드로 변환.
- **링커**: 그 목적 코드와 라이브러리를 결합해 “실행 가능한 파일”을 생성. (자바는 없음)

|  | **C 언어** | Java |
| --- | --- | --- |
| **소스코드 파일 (컴파일 전)** | .cpp | .java |
| **실행 파일 (컴파일 후의 바이너리 데이터)** | .exe, .out | .class |
| **링커 유무** | O | X |
| **실행 장소** | OS 위 | OS 위에서 동작하는 **JVM** 위 |

### 프로세스의 상태

- **생성**: 새로운 프로세스 생성. (PCB 할당)
- **대기**: 메모리를 할당받기 전, CPU 소유권을 기다리는 상태.
- **~~대기 중단**: 메모리 부족으로 대기가 중단된 상태.~~
- **실행**: CPU 소유권과 메모리를 할당받아 instruction(프로세스 내 명령어)를 수행중인 상태.
- **중단**: 프로세스가 강제로 종료된 상태. (예: I/O 디바이스에 의한 인터럽트)
- **~~일시 중단**: 메모리 부족으로 실행이 일시 중단된 상태.~~
- **종료**: 프로세스가 완료되어 CPU 소유권과 메모리를 두고가는 상태.

### 프로세스의 메모리 할당구조 (❗ Java와 연결 가능한 논점)

|  | **저장되는 것** | **할당/소멸** |
| --- | --- | --- |
| **Stack** | local 변수, 매개변수 | “함수 호출시” 할당, 함수 완료시 소멸 |
| **Heap** | 동적 할당 변수 | **new** 연산으로 생성, 필요 없어지면 **GC**가 삭제 |
| **BSS segment** | “초기화되지 않은” global, static 변수 |  |
| **Data segment** | “초기화된” global, static 변수 |  |
| **Code segment** | 실행 명령 (함수, 제어문, 상수)
→ CPU가 하나씩 처리 |  |
- 메모리의 높은 주소부터 낮은 주소 순
- Stack, Heap 영역은 “런타임시” 동적으로 할당
- 데이터, 코드 영역은 “컴파일시” 정적으로 할당 → “프로세스 생성시”(=프로그램 시작시) 할당되고, 종료시 소멸

### PCB

- 프로세스에 대한 중요 정보(상태, 카운터, 레지스터 등)를 담은 “메타 데이터” 블록.
- “프로세스 생성시” OS가 생성한다.
- **중요성 - 컨텍스트 스위칭**: “PCB를 기반으로” 프로세스 상태를 저장하고 로드한다.

### 멀티 프로세싱

- 여러 프로세스를 이용해 여러 일을 병렬로 동시에 처리하는 방식.
- **웹 브라우저**: 여러 프로세스(브라우저, 렌더러, 플러그인, GPU 등)를 사용해 성능과 안정성을 향상.
- **IPC**: 프로세스 간 데이터를 교환하는 방법. (예: 클라이언트-서버)
- **IPC의 종류**: 공유 메모리, 파일, 소켓, 파이프(익명/명명), 메시지 큐 등 다양한 방식 존재.

### 멀티 스레딩

- 한 프로세스 내에서 여러 스레드를 병렬 처리하는 방식. (예: 웹 브라우저의 렌더러 프로세스를 구성하는 여러 스레드)
- **장점:** 힙,데이터,코드 영역을 공유하기 때문에 (스택은 제외), 멀티 프로세싱보다 효율성과 동시성이 높다.
- **단점:** 한 스레드에 문제가 생기면 다른 스레드에도 영향을 줄수있다.

### 임계영역

- 둘 이상의 프로세스나 스레드가 “같은 공유자원”에 접근(race condition)하면 결과가 달라질 수 있는 코드 영역
- **해결 조건:** 상호 배제, 한정 대기, 융통성
- **mutex:** 공유자원에 대해 “lock/unlock”으로 접근을 처리하는 객체.
- **semaphore:** 일반화된 mutex로서, “wait/signal”로 접근을 처리하는 객체.
- **monitor:** 공유자원에 대한 인터페이스만 제공하고, 모니터 큐로 접근 작업들을 순차 처리하는 객체.

### 데드락⭐

- **개념**: 여러 프로세스가 “서로가 가진 자원”을 기다리며 중단된 상태에서 발생하는 교착상태. (~~race condition~~ 아님!)
- **원인**: 상호 배제, 점유/순환 대기, 비선점 등이 그 원인.
- **해결방법**: 은행원 알고리즘(데드락 가능성이 없을때만 자원 할당), 사이클이 일어나면 관련된 프로세스를 하나씩 지우기 등

# 4. CPU 스케줄링 알고리즘

- **목표**: 효율적인 CPU 사용, 대기 시간 최소화, 공정성 유지.
- **비선점형 방식**: 실행 중인 프로세스를 끝날 때까지 유지. 컨텍스트 스위칭에 의한 부하가 적다.
    - **FCFS(First Come, First Served):** “가장 먼저 온” 프로세스 먼저 처리 / 지나치게 오래 기다리는 단점(convoy effect)
    - **SJF(Shortest Job First):** “실행시간이 가장 짧은” 프로세스 먼저 처리 / 실행시간이 긴 프로세스가 처리되지 않는 단점(starvation)
    - **우선순위:** SJF를 “오래된 작업의 우선순위를 높여(align)” 해결
- **선점형 방식**: 현재 프로세스를 강제로 중지하고 다른 프로세스에 CPU 소유권을 할당
    - **Round Robin (현대 OS가 사용):** 각 프로세스에 “동일한 시간”을 할당
    - **SRF(Shortest Remaining time First):** “현재 프로세스의 남은 시간보다 더 짧은” 작업이 들어오면 대체
    - **다단계 큐:** 우선순위가 다른 큐 여러 개에 각각 다른 스케줄링 알고리즘을 적용
