## 운영체제의 구조

lower → higher level

하드웨어 → [커널 → 시스템콜 → 인터페이스] → 유저프로그램

[    ] 내부가 운영체제

- 시스템콜
    - 운영체제가 커널에 접근하기 위한 인터페이스. 유저 프로그램이 커널 함수 요청 시 사용
    - 유저 프로그램이 I/O 요청 시 유저모드 → 시스템모드 변경
    - 이를 통해 유저 모드/시스템 모드 분리
    - 프로세스 → 시스템콜 → 커널 → OS
    - 작동 시 modebit을 활용 해 모드 구분
        - modebit: 0(커널 모드) or 1(유저 모드), 시스템콜 호출시 커널 모드로 변경되어 작업 수행 후 유저 모드로 변경되어 작업 수행
        

## 컴퓨터의 요소

- CPU ⇒ 산술논리연산장치 + 제어장치 + 레지스터
    - 산술논리연산장치 (ALU)
        - 산술 연산(+, - …)  논리합, 논리곱 등
    - 제어장치 (C)
        - 프로세스 조작, 통신 제어
    - 레지스터 (R)
        - CPU 내부 빠른 메모리. CPU와 직연결로 RAM보다 훨씬 빠름.
        - CPU는 데이터 저장을 못해 레지스터 이용해 데이터 전달
    - 커널이 메모리에 프로그램을 올려 → 프로세스를 만들면 CPU가 처리
    - 연산 과정
        1. C가 R, 메모리에 연산할 값 올림
        2. C가 레지스터의 값 연산할 것 ALU에 명령
        3. C가 계산된 값 레지스터 → 메모리 이동 후 저장
    - 인터럽트 - CPU의 일시 정지
        - 하드웨어 인터럽트: IO 디바이스의 인터럽트 (키보드, 마우스 등)
        - 소프트웨어 인터럽트: 프로세스의 시스템콜 호출, 속칭 trap.
- DMA 컨트롤러 ⇒ I/O 디바이스가 메모리에 접근할 수 있도록 하는 장치. CPU 부하 방지
- 메모리 ⇒ 데이터, 상태, 명령어 등 저장. 주로 RAM을 메모리라 부름.
- 타이머 ⇒ 프로그램에 작업 시간 제한을 건다
- 디바이스 컨트롤러 ⇒ I/O 디바이스의 작은 CPU

## 메모리

레지스터 - 캐시 - RAM (주기억장치) - HDD/SSD (보조기억장치)

← 속도🔼, 휘발성                                                  기억 용량🔼 →

- 캐시
    - 임시 저장소, 장치간의 속도 차이로 인한 병목 현상 최소화 (캐싱 계층)
    - 캐시 선정 기준
        - 시간 지역성: 최근 접근 데이터(그 자체)
        - 공간 지역성: 최근 접근한 데이터의 공간이나 그 근처
    - 캐시 히트: 원하는 데이터를 찾아 캐시에서 가져옴. [CPU 버스]
    - 매시 미스: 캐시에 없어 메모리에서 가져옴. [시스템 버스]
    - 캐시 매핑 방법: 직접, 연관, 집합 연관

## 메모리 관리

- 가상 메모리
    - 가상의 공간을 할당해 용량을 커보이게 하고 가상 주소와 실제 주소를 매핑
- 페이지 폴트
    - 가상 메모리에는 존재하나 실제 메모리에는 존재하지 않는 데이터에 접속 시도 시 발생
- 스와핑
    - 메모리의 사용하지 않는 데이터를 HDD로 옮기고 HDD의 일부를 메모리에 불러오는 것
    - (페이지가 존재하지 않는)가상 주소 접근 → trap 발생 → HDD의 사용하지 않은 프레임 발견 → 실제 메모리에 가져와 페이지 교체 → 명령 재시작
- 스래싱
    - 페이지 폴트율이 높은 상태. CPU 이용률이 낮아 더 많은 프로세스를 메모리에 올려 상황이 심각해진다
    - 작업 세트: 과거 사용한 페이지 집합을 만들어 메모리에 로드해 놓는 것
    - PFF: 페이지 폴트의 상한선과 하한선 설정

### 메모리 할당

- 연속 할당: 프로세스 당 순차적으로 공간 할당
    - 고정 분할: 메모리를 미리 나누어 놓는다. 내부 단편화 ⇒ 나눠진 메모리보다 프로그램이 작아 못 들어감
    - 가변 분할: 메모리를 동적으로 나눈다. 외부 단편화 ⇒ 나눠진 메모리보다 프로그램이 커 못들어감
- 불연속 할당: 메모리를 동일한 크기의 페이지들로 나눠 프로그램마다 페이지 테이블 지정
    - 페이징: 동일한 크기로 나눈 메모리 구역. 서로 다른 위치에 프로세스를 할당할 수 있다
    - 세그멘테이션: 페이지 단위가 아닌 세그먼트 단위
    - 페이지드 세그멘테이션: 프로그램을 세그멘테이션해 페이지 단위로 나눈다

### 페이지 교체 알고리즘

- 오프라인 알고리즘
    - 미래의 페이지 ↔ 현재 페이지
    - 이상적이나 불가능. 각 방법의 efficiency 비교용
- FIFO
    - 가장 먼저 온(사용 여부와 관계없이 가장 오래 된) 페이지 교체
- LRU (Least Recently Used)
    - 참조가 가장 오래된 페이지 교체
    - 할당된 지 오래 지났어도 최근에 계속 참조되면 교체되지 않음
- NUR (Not Used Recently)
    - 시계 방향으로 돌며 참조되지 않은 페이지 교체
- LFU (Least Frequently Used)
    - 가장 참조 횟수가 적은 페이지 교체

## 프로세스와 스레드

프로그램이 메모리에 올라가면 instantiate 되어 프로세스가 되고 CPU가 이를 실행함

e.g.) chrome.exe 실행 시 chrome 프로세스 변환

### 컴파일 과정

소스코드 → 전처리 → 컴파일러 → 어셈블리어 → 어셈블러 → 목적 코드 (+ 라이브러리) → 링커 → 실행 파일

- 전처리: 소스코드 주석 제거 등
- 컴파일러: 코드 최적화 후 어셈블리어 변환
- 어셈블러: 목적 코드로 변환
- 링커: 프로그램 내 라이브러리 함수 등과 목적 코드 결합해 실행 파일 생성 (.exe)

### 프로세스의 상태

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/b81ccf9c-a77c-4335-804e-0afc2d11950b/911edd21-e61c-41d8-88be-6c05c8e38ef7/image.png)

- 생성 상태
    - 프로세스가 fork() or exec() 함수로 생성된 상태. PCB는 이때 할당
    - fork: 부모 공간 단순 복사, exec: 새로운 프로세스 생성
- 대기 상태
    - CPU 소유권을 기다리는 상태
    - suspend ready: 메모리 부족으로 일시 중단
- 실행 상태
    - CPU 소유권과 메모리를 할당받아 명령을 수행 중인 상태
- 중단 상태
    - 프로세스가 차단된 상태 (I/O Interruption 등)
    - suspend block: 메모리 부족으로 프로세스의 실행 일시 중단
- 종료 상태
    - CPU 소유권과 메모리를 돌려 놓고 프로세스 종료
    - 정상 종료, 비정상 종료 모두 포함

### 프로세스의 메모리 구조

동적 영역 [스택 - 힙]

정적 영역 [데이터 영역 - 코드 영역] 

- PCB (Process Control Block)
    - 프로세스 생성 시 생성, 프로세스에 대한 메타데이터 저장
    - 메타데이터: 스케줄링 상태, 프로세스 ID 등
- 컨텍스트 스위칭: PCB의 데이터를 이용해 프로세스를 저장/로드해 멀티 프로세싱하는 것
    - A 저장 → B 로드 → B 저장 → A 로드 → A 저장 → … 반복
    - 로드 시마다 캐시클리어 과정 필요해 비용 발생 (캐시미스)

### 멀티프로세싱

- IPC (Inter-Process Communication)
    - 공유 데이터 관리 메커니즘
    - 공유 메모리
    - 파일
    - 소켓 (TCP, UDP)
    - 익명파이프: 프로세스 간의 FIFO 읽기/쓰기 전용 파이프
    - 명명된 파이프: 하나 이상의 단/양방향 파이프
    - 메시지 큐

### 멀티스레딩

스레드: 프로세스의 실행 가능한 가장 작은 단위

코드, 데이터, 힙 공유 but 스택은 공유 안함

한 스레드가 중지되어도 다른 스레드는 실행 중이어서 프로세스 중단되지 않음, but 문제가 생기면 다른 스레드에 영향을 줄 수 있음

- 공유 자원
    - 시스템 안에서 각 프로세스/스레드 (단위 당) 함께 접근 가능한 자원
    - Race Condition (경쟁 상황): 두 개 이상의 유닛이 동시에 읽고 쓰는 상황
- 임계 영역
    - 둘 이상의 유닛이 공유 자원에 접근할 때 순서로 결과가 달라지는 코드 영역
    - 해결 조건
        - 상호 배제 : 한 프로세스가 임계 영역 점유시 다른 프로세스 출입 불가
        - 한정 대기 : 특정 프로세스가 영원히 임계 영역에 접근할 수 없어선 안됨
        - 융통성 : 임계 영역을 사용하는 프로세스가 없다면 아무나 사용 가능, 이때 서로 방해하지 말 것
    - 해결 방안 (위의 3조건 충족)
        - 뮤텍스 (잠금) : lock(), unlock()을 통해 공유 자원 접근 제한
        - 세마포어 (시그널링) : 유닛이 공유자원 점유시 wait(), 공유자원 해제 시 signal()
        - 바이너리 세마포어 : 0과 1의 값을 가진 세마포어 (시그널링)
        - 카운팅 세마포어 : 여러 값을 가짐. 여러 자원에 대한 접근 관리
        - 모니터 : 공유 자원 자체는 숨기고 접근 인터페이스만 제공 (내부에 큐를 사용)
    

### 교착 상태 (Deadlock)

- 원인
    - 상호 배제 : 한 유닛이 자원 독점, 다른 유닛은 접근 불가
    - 점유 대기 : 한 유닛이 점유한 자원을 다른 유닛이 요청한 상태
    - 비선점 : 다른 유닛의 자원을 강제로 빼앗아올 수 없음
    - 환형 대기 : A → B 요구, B → A 요구
- 해결 방법
    - 위의 조건이 성립하지 않도록 설계
    - 데드락 가능성이 없을 때만 자원 할당, 은행원 알고리즘 사용 (안정성 판별해 안정적인 곳에 할당)
    - 데드락 발생 시 사이클을 찾아 프로세스 하나씩 제거

## CPU 스케줄링 알고리즘

목표: 높은 CPU 이용률, 많은 일, 짧은 응답 시간, ready queue 최소화

### 비선점형 방식

프로세스 강제 중지 불가능. 프로세스가 스스로 CPU 소유권을 포기, context switching 부담🔽

- First Come First Served
    - 먼저 온 순서대로 처리
    - 큐 대기 시간이 길어지는 convoy effect 발생
- Shortest Job First
    - 실행 시간(과거의 실행시간을 토대로 추측한 것)이 짧은 프로세스부터 실행
    - 실행 시간이 긴 프로세스는 실행되지 않는 starvation 현상 발생
- 우선순위
    - 대기 큐에서 오래된 프로세스일수록 우선순위를 높임

### 선점형 방식 ← 현재 운영체제 사용

프로세스 강제 중지 후 다른 프로세스에 CPU 소유권 할당

- Round Robin
    - 각 프로세스에 동일한 선점 시간을 주고 준비 큐를 돌리는 것
    - 선점 시간 🔼 : FCSC의 단점
    - 선점 시간 🔽 : context switching 인한 오버헤드 발생
    - 전체 작업 시간 🔼, 평균 응답 시간 🔽
- Shortest Remaining Time First
    - 프로세스 실행 중 더 짧은 작업이 들어오면 중지 후 해당 프로세스 실행
- 다단계 큐
    - 우선순위에 따라 여러 큐(각자 다른 스케줄링 알고리즘) 사용
    - 큐 간 프로세스 이동 불가능
