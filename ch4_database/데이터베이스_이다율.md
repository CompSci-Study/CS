## 데이터 베이스 

### 데이터 베이스의 기본 
데이터 베이스 : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음 
DBMS : 데이터 베이스를 제어, 관리하는 통합 시스템 

> 엔티티 Entity : 테이블 

여러 개의 속성을 지닌 명사를 의미하며, 업무상 관리가 필요한 것. 두 개 이상의 인스턴스의 집합.

|구분|	속성 (Attribute)|	인스턴스 (Instance)|
|--|--|--|
|정의|	엔티티의 특성이나 데이터 항목을 의미함.|	엔티티의 구체적인 데이터나 사례를 의미함.|
|역할|	테이블의 열(Column).|	테이블의 행(Row).|
|예시|	학번, 이름, 학과, 생년월일.|	2023001, 홍길동, 컴퓨터공학, 2001-01-01.|
|관계|	데이터를 정의하는 데 사용됨.|	속성의 값을 기반으로 하나의 데이터를 구성.|

> 속성  

구체적이고 고유한 이름을 갖는 정보, 컬럼 (열)

> 카디널리티 

데이터베이스에서 특정 컬럼(속성)의 고유한 값(Unique Value)의 개수, 한 속성(컬럼)에 얼마나 다양한 값이 존재하는지 측정

> 도메인 

릴레이션 (RDM - 테이블, NoSQL - 컬렉션)에 포함된 각각의 속성들이 가질 수 있는 값의 집합 
<br>
ex. 남, 여 

> 필드와 레코드 

필드 : 열 column <br>
- 날짜타입 : DATE, DATETIME, TIMESTAMP
- 문자타입 : CHAR, VARCHAR, TEXT, BLOB, ENUM, SET <br>

레코드 : 행 row

> 키 

데이터베이스에서 **레코드**를 고유하게 식별하거나, 테이블 간의 관계를 정의하는 데 사용되는 속성(또는 속성들의 집합)을 의미.
키를 통해 데이터의 무결성을 유지하고, 효율적으로 데이터를 검색하거나 조작할 수 있음.
<br>
ex. 기본키, 외래키, 후보키, 슈퍼키, 대체키 

|-| 기본키 | 외래키 | 후보키 | 대체키 | 슈퍼키 |
| -- | -- | -- | -- | -- | -- |
|정의 | 후보 키 중에서 대표적으로 선택된 키. <br> 레코드를 고유하게 식별하며, NULL 값을 허용하지 않음. | 다른 테이블의 기본 키를 참조하는 속성. <br> 테이블 간의 관계를 정의하고 데이터의 **Referential Integrity**을 유지. | 레코드를 고유하게 식별할 수 있는 최소한의 속성 집합. <br> 유일성과 최소성을 동시에 만족. | 후보 키 중에서 기본 키로 선택되지 않은 나머지 키. | 테이블의 **레코드**를 고유하게 식별할 수 있는 하나 이상의 속성들의 집합. <br> 속성이 하나라도 추가되어 고유성을 유지하면 슈퍼 키가 됨. |
|특징 | 하나의 테이블에는 기본 키가 하나만 존재. <br> 자동으로 **index**가 생성되어 데이터 검색 성능이 향상됨.| 외래 키 값은 참조하는 기본 키 값에 존재하거나, NULL이어야 함. <br> 부모-자식 관계를 정의.| 테이블에 여러 개의 후보 키가 있을 수 있음. <br> 후보 키 중에서 하나를 기본 키로 선택. | 기본 키를 제외한 후보 키를 의미. <br> 테이블의 무결성을 유지할 때 사용 가능. | 유일성을 보장하지만, 최소성은 보장하지 않음. <br> 모든 키(기본 키, 후보 키 등)는 슈퍼 키의 부분 집합. |
|예시 | 기본 키: {학번} | - | 후보 키: {학번}, {이름, 생년월일} (학번과 이름+생년월일 모두 최소성을 가짐)| 대체 키: {이름, 생년월일} | 슈퍼 키: {학번}, {학번, 이름}, {학번, 생년월일} |



## ERD와 정규화 과정 

### ERD(Entity-Relationship Diagram) 의 중요성 
데이터베이스 설계의 시각적 도구로, 데이터 간의 관계를 명확히 이해하고 설계를 도움 <br>
ERD는 데이터베이스 설계의 기초를 제공하며, 이를 기반으로 논리적 데이터 모델링과 물리적 데이터 모델링을 수행

### 데이터베이스 정규화 
> 장점

**중복 데이터 제거**: 데이터를 여러 곳에 중복 저장하지 않도록 구조화. <br>
**데이터 무결성 보장**: 불필요한 데이터 수정이나 삭제로 인한 오류 방지. <br>
**효율적 데이터 저장**: 저장 공간을 절약하고 데이터 관리 비용을 줄임. <br> 
**확장성과 유연성 향상**: 데이터베이스를 확장하거나 수정할 때의 부담을 줄임. <br>
> 단점 

**복잡성 증가**: 정규화가 진행될수록 테이블 수가 증가하여 복잡해질 수 있음. <br>
**쿼리 성능 저하**: 데이터를 여러 테이블에서 조회해야 하므로 성능이 저하될 가능성. <br>
**과도한 분리**: 실제 비즈니스 로직에 비해 지나치게 세분화되면 관리가 어려워질 수 있음. <br>
따라서 **반정규화** (정규화된 테이블을 다시 합치거나 중복을 허용)가 필요할 때도 있음 

- 첫 번째 정규형(1NF): 모든 속성이 원자값을 가져야 함, 한 칸에는 하나의 데이터만 
- 두 번째 정규형(2NF): 부분 함수 종속성 partial dependency 을 제거 = fully functionally dependent, 현재 테이블의 주제와 관련없는 컬럼을 다른 테이블로 분리
- 세 번째 정규형(3NF): 속성간에 이행적 종속성(transitive FD)이 없어야 함   <br>
    학생 + 학과 + 학과명 => 학생 + 학과 | 학과 + 학과명 
- BCNF(Boyce-Codd Normal Form): 모든 결정자가 후보 키여야 함. BCNF ⊆ 3NF <br>
    강의 + 교수명 + 강의실 => 강의 + 교수명 | 교수명 + 강의실 


## 트랜젝션과 무결성 
### 트랜잭션 
**정의** : 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 여러 개의 연산이 수행될 수 있음. 수행 중에 한 작업이라도 실패하면 모두 실패하고, 모두 성공해야 성공이라고 할 수 있음 

### 트랜잭션의 특징 
> 원자성 (atomicity)

커밋으로 모든 트랜잭션이 반영되던지, 아니면 롤백으로 전혀 반영되지 않으므로 데이터의 무결성이 보장 <br>
시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 완료 후의 상태가 같아야 함 

> 일관성 (consistency)

데이터 무결성을 유지하여 잘못된 데이터가 삽입되지 않도록 보장

> 격리셩 (isolation)

둘 이상의 트랜잭션이 동시에 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜젝션의 연산이 끼어들 수 없음  <br>
격리 레벨 : **동시성**이 높은 순이고 **격리성**이 낮은 순에서 *동시성*이 낮고 *격리성*이 높은 순으로 <br>

READ_UNCOMMITED >> READ_COMMITTED >> REPEATABLE_READ >> SERIALIZABLE
- Dirty Read : 아직 커밋되지 않은 데이터를 읽을 수 있음
- Non-repeatable Read : 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했을 때 값이 다른 경우, 행 값이 달라질 수 있음 
- Phantom Read : 동일한 쿼리를 보냈을 때 예상 결과가 다른 경우, 다른 행이 선택될 수 있음 

|격리 수준 | 설명 | Dirty Read | Non-repeatable Read | Phantom Read | Concurrency |
|--|--|--|--|--|--|
|READ UNCOMMITTED|- 커밋되지 않은 데이터도 읽을 수 있음 <br> - 동시성은 가장 높지만, 데이터 정합성이 낮음.|O|O|O|가장 높음|
|READ COMMITTED|- 커밋된 데이터만 읽을 수 있음 <br>- 트랜잭션이 커밋되기 전까지 변경된 데이터는 보이지 않음.|X|O|O|높음|
|REPEATABLE READ|- 트랜잭션 동안 동일한 데이터를 여러 번 조회해도 값이 변하지 않음 <br> - InnoDB(MySQL)의 기본 격리 수준|X|X|O|보통|
|SERIALIZABLE|- 가장 엄격한 격리 수준 <br>- 모든 트랜잭션을 순차적으로 실행하는 것처럼 동작|X|X|X|가장 낮음|

> 지속성 (durability)

트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영됨

### 트랜잭션의 상태

```
    (시작)
      ↓
 [Active] → [Partially Committed] → [Committed]  (성공)
      |                          |
      |                          → [Failed] → [Aborted]  (롤백)
      → [Failed] → [Aborted]  (롤백)

```

### 무결성 integrity
|무결성 유형|설명|
|-- | --|
|개체 무결성 (Entity Integrity)	|모든 테이블은 기본 키(Primary Key)를 가져야 하며, 기본 키의 값은 고유(unique)하고 NULL이 될 수 없음.|
|참조 무결성 (Referential Integrity)|외래 키(Foreign Key) 제약 조건을 통해 테이블 간의 관계를 유지하며, 외래 키 값은 NULL이거나 참조하는 기본 키와 동일해야 함.|
|도메인 무결성 (Domain Integrity)	|특정 컬럼(속성)이 정의된 데이터 타입과 값의 범위를 준수해야 함. (CHECK, NOT NULL, DEFAULT 제약 조건 활용)|
|고유성 무결성 (Unique Integrity)|특정 열(Column)의 값이 중복되지 않도록 보장. (UNIQUE 제약 조건 활용)|
|NULL 무결성 (Null Integrity)	|특정 컬럼이 NULL 값을 가질 수 있는지 여부를 제한 (NOT NULL 제약 조건 활용).|



## 데이터베이스의 종류 
### 관계형 데이터베이스 RDBMS
테이블 간의 관계를 통해 데이터를 저장, 행과 열을 가지는 표 형식 <br>
SQL을 사용하여 데이터를 저장, 조회, 수정, 삭제할 수 있음 <br>
데이터를 효율적으로 저장하고 관리하며, 데이터 무결성과 ACID특성을 보장 <br>
EX. MySQL, PostgreSQL, 오라클, SQL Server 등 <br>
MySQL: 빠르고 가벼운 웹 애플리케이션, 블로그, CMS 등에 적합. <br>
PostgreSQL: 복잡한 트랜잭션, 데이터 분석, 금융 시스템, GIS, 대규모 데이터 저장소 등에 적합.

### SQL 
|종류|설명| 주요 명령어|
|-- | -- | -- |
|DDL (Data Definition Language)	|데이터베이스, 테이블 등을 정의 |CREATE, ALTER, DROP, TRUNCATE|
|DML (Data Manipulation Language) |테이블 데이터를 조작	|SELECT, INSERT, UPDATE, DELETE|
|DCL (Data Control Language)	|사용자 권한을 제어	|GRANT, REVOKE|
|TCL (Transaction Control Language) |트랜잭션을 관리 |COMMIT, ROLLBACK, SAVEPOINT|

### NoSQL 데이터베이스 
행, 열 구조를 따르지 않고 스키마가 유연하며, 수평 확장이 용이 <br>
EX. Redis (싱글스레드), MongoDB 등 <br>


## 인덱스 
**인덱스**는 추가적인 저장 공간을 사용하여 데이터 검색 속도를 향상시키는 자료구조 <br>
[장점] <br>
- 검색 속도 향상 (데이터가 정렬되어 빠르게 조회 가능) 
- 대량의 데이터에서도 효율적인 검색 수행
- 데이터 집합 연산 최적화

[단점] <br>
- 추가적인 저장 공간이 필요 (인덱스도 데이터로 저장됨) 
- 데이터 변경에 따른 오버헤드
- 인덱스 선택과 관리의 복잡성

### 인덱스의 자료구조 
> B-Tree 인덱스 (기본 인덱스)

- 대부분의 데이터베이스는 B-Tree 기반의 인덱스를 사용하여 균형 트리 형태로 데이터를 정렬함.
- 검색, 삽입, 삭제가 비교적 빠름 -> 대수확장성 (깊이가 노드 수에 비해 매우 느리게 성장, 깊이 10만, 노드 100만 이상)

> 해시 인덱스 (Hash Index)

- 특정 값에 대한 빠른 검색(=, IN 연산)에 유리하지만, 범위 검색(>, <, BETWEEN)에는 적합하지 않음.


### 인덱스 종류 
> Clustered Index 

데이터가 테이블에 물리적으로 저장되는 순서를 정의, 실제 데이터가 정렬되어 검색 시 빠른 성능 <br>
테이블당 하나의 Clustered Index만 존재, 리프 노드에 실제 데이터의 페이지가 들어있음 

> Non - Clustered Index 

리프 노드에는 데이터 페이지에 대한 포인터가 있고, 포인터로 페이지 조회, 정렬되지 않음. 

### 인덱스 최적화 조건

✔ WHERE 조건에 자주 사용되는 컬럼에 인덱스 추가<br>
✔ 카디널리티가 높은 컬럼을 우선적으로 인덱스 적용<br>
✔ 자주 JOIN 되는 컬럼에 인덱스 추가<br>
✔ ORDER BY, GROUP BY에서 정렬되는 컬럼에 인덱스 적용<br>
✔ 인덱스가 과도하게 많으면 성능 저하, 적절한 개수 유지<br>


## Join 
### 종류 
|JOIN 유형	|설명|일치하지 않는 데이터 포함 여부|
|--|--|--|
|INNER JOIN	|공통 키 기준으로 양쪽 테이블에서 일치하는 데이터만 반환	|❌ (일치하지 않는 데이터는 제외)|
|LEFT JOIN (LEFT OUTER JOIN)	|왼쪽 테이블의 모든 데이터 + 오른쪽 테이블에서 일치하는 데이터만 반환	|⭕ (왼쪽 테이블 데이터는 모두 포함, 오른쪽에 없는 데이터는 NULL)|
|RIGHT JOIN (RIGHT OUTER JOIN)	|오른쪽 테이블의 모든 데이터 + 왼쪽 테이블에서 일치하는 데이터만 반환	|⭕ (오른쪽 테이블 데이터는 모두 포함, 왼쪽에 없는 데이터는 NULL)|
|FULL OUTER JOIN	|양쪽 테이블의 모든 데이터 포함 (합집합)	|⭕ (일치하지 않는 데이터도 포함, 없는 값은 NULL)|

### 원리 
> 중첩 루프 조인 

중첩 for 반복문과 같은 원리로 조건에 맞는 조인을 하는 방법, 랜덤 접근에 대한 비용이 많이 증가해서 대용량의 테이블에 부적합

> 정렬 병합 조인

각각의 테이블들을 조인할 필드 기준으로 정렬하고 조인, 인덱스가 없고 대용량의 테이블들을 조인하고, 조건으로 <, > 등 범위 비교 연산자가 있을 때 사용 

> 해시 조인 

해시 테이블을 기반으로 조인, 테이블을 한 번만 조회해서 중첩 루프 조인보다 성능이 좋음 

- 빌드 단계 : 작은 테이블을 해시 테이블로 변환
- 프로브 단계 : 레코드를 읽고, 조인 키 값과 일치하는 레코드를 찾아 반환 
