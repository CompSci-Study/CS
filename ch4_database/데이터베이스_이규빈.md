# CS스터디 4회차 - DB

날짜: 2025년 1월 23일

# 1. DB 기본

### 용어

- **Entity**: 데이터를 저장하기 위한 실체로, 물리적 또는 개념적 대상. (예: 고객, 제품)
- **Relation(RDB - Table, NoSQL - Collection)**: 데이터를 저장하는 구조적 기본단위
- **Attribute**: Entity의 특징이나 속성을 나타내는 요소. (예: 이름, 나이)
- **Domain**: Attribute가 가질 수 있는 값의 집합. (예: 나이의 도메인은 0~120)

### Key

- **슈퍼키**: 테이블에서 행을 고유하게 식별할 수 있는 속성. (**유일성** 만족)
- **후보키**: 기본키로 사용할 수 있는 모든 키. 기본키는 후보키 중 하나를 선택하여 결정함. (**유일성 + 최소성** 만족)
- **기본키(PK)**: 테이블 내에서 각 행을 고유하게 식별하는 키. 중복 불가, NULL 불가.
- **대체키**: 후보키 중 기본키로 선택되지 않은 키.
- **외래키(FK)**: 다른 테이블의 기본키를 참조하는 키로, 테이블 간의 관계를 표현함.

# 2. ERD, 정규화

- **ERD**: Entity 간의 관계를 정의한 다이어그램. (시스템 요구사항 → ERD → DB 구축)
- **정규화**: DB 이상현상을 해결하고 데이터를 효율적으로 저장하기 위해, 테이블을 분리하는 과정.

|  | **의미** | **예시** |
| --- | --- | --- |
| **제1정규형** | 모든 속성이 **원자값**만을 가져야 한다. | '취미' 컬럼에 여러 개의 취미를 쉼표로 구분하여 저장하지 않고, 각 취미를 별도의 행으로 분리. |
| **제2정규형** | 제1정규형을 만족하면서, 기본키의 **부분 함수 종속성을 제거.** | 주문 테이블에서 “상품 ID” 기본키에 대해 “상품 정보”가 부분 종속될 경우 상품 테이블로 분리. |
| **제3정규형** | 제2정규형을 만족하면서, **이행적 함수 종속을 제거.** | 직원 테이블에서 “부서 ID”를 통해 “부서 이름”을 참조할 경우, 부서 테이블로 분리함. |
| **보이스-코드 정규형 (BCNF)** | 제3정규형을 만족하면서 **모든 결정자가 후보키**여야 함. | 복합키 테이블에서 한 속성이 다른 속성을 결정하는 경우 테이블을 분리하여 종속성을 제거함. |

# 3. 트랜잭션 ⭐

### 정의

- **트랜잭션**: 여러 쿼리를 묶어 하나의 논리적 기능을 수행하기 위한 작업 단위.
- **무결성**: 데이터의 정확성과 일관성을 유지하는 성질로서, 데이터 값과 현실 세계의 실제 값 일치의 전제 조건이 된다. 트랜잭션이 ACID 속성을 준수해야만 무결성을 유지할 수 있다.

### Atomicity

- **의미**: 트랜잭션 내의 모든 작업이 완전하게 수행되어 DB에 영구 저장(**commit**)되거나, 중간에 이슈 발생시 트랜잭션 전체가 취소됨(**rollback**)을 보장하는 속성.
- **예시**: 은행 계좌 이체에서 “출금”과 “입금”이 모두 성공하거나, 모두 취소되는 경우.

### Consistency

- **의미**: 트랜잭션이 “유효한 논리적 상태”에서만 작업을 수행해야 하는 속성.
- **예시**: 계좌 잔액이 모자란 경우, 논리적으로 송금이 불가능.

### Isolation

- **의미**: 여러 트랜잭션이 동시에 실행될 때 서로 간섭하지 않아야 하는 속성.
- **예시**: 동시에 실행되는 “주문 생성”과 “재고 감소” 트랜잭션이 서로 영향을 미치지 않아야 한다.
- **트랜잭션 격리 수준**

| **격리 수준** | **설명** | **발생 가능한 동시성 문제** | **특징 및 주의사항** |
| --- | --- | --- | --- |
| **SERIALIZABLE** (격리성, 데이터 일관성 높음) | 트랜잭션을 순차적 실행. | 없음 | 완전한 데이터 일관성을 보장하지만, 성능 저하가 클 수 있다. |
| **REPEATABLE READ**  | “동일” 트랜잭션 내에서 동일한 데이터를 읽으면 항상 동일한 결과를 보장. 즉 “다른” 트랜잭션은 **(추가/삭제는 가능하나) 수정 불가.** | Phantom Read | Non-Repeatable Read를 방지. (MySQL 기본값) |
| **READ COMMITTED**  | 다른 트랜잭션이 “commit해야만” 조회 가능. | Phantom Read, Non-Repeatable Read | Dirty Read는 방지되지만, 같은 쿼리를 반복 실행 시 결과가 달라질 수 있다. (PostgreSQL, 오라클 기본값) |
| **READ UNCOMMITTED** (동시성, 성능 높음) | 다른 트랜잭션이 “commit하지 않아도” 조회 가능. | Phantom Read, Non-Repeatable Read, Dirty Read | 가장 낮은 격리 수준으로 성능은 좋지만 데이터 일관성이 떨어질 수 있다. |
- **동시성 문제**
    - **Phantom Read**: 동일 쿼리를 실행할 때 **“레코드”**가 추가되거나 삭제되어 결과가 달라짐.
    - **Non-Repeatable Read**: 동일 트랜잭션 내에서 동일한 **“데이터 값”**을 읽을 때 결과가 다름.
    - **Dirty Read**: 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽음.

### Durability

- **의미**: 트랜잭션이 commit되었다면 시스템 장애가 발생해도 결과가 유지되어야 하는 속성. Checksum, Journaling, Rollback 등을 통해 보장된다.
- **예시**: 결제 완료 후 시스템 장애가 발생한 경우, DB를 복구하면 결제 기록이 남아 있어야 한다.

# 4. DB의 종류

| ⭐ | **특징** | **강점** |
| --- | --- | --- |
| **RDB** | 고정된 스키마를 가지며, 관계를 기반으로 “테이블” 형식 데이터를 저장. | 데이터 일관성이 높음. 조인 등 복잡한 데이터 처리가 필요할 때 적합. |
| **NoSQL** | 유연한 스키마를 가지며, “컬렉션” 형식으로 비정형 데이터를 저장. | 확장성이 뛰어남. 데이터 수정보다는 빅데이터를 빠르게 삽입할 때 유리. |

|  | **설명** | **특징** | **활용예시** |
| --- | --- | --- | --- |
| **MySQL** | 스토리지 엔진을 쉽게 바꿀수 있고, 트랜잭션 처리에 강점을 가지는 RDBMS. | 모듈식 아키텍처로 설계되어 있고, SQL 쿼리를 통해 데이터 조작을 수행. | **전자상거래 플랫폼**(예: 상품, 주문 데이터 관리), **블로그 시스템**(예: 게시글 및 댓글 관리), **고객 관리 시스템**(CRM), **인벤토리 관리 애플리케이션**. |
| **PostgreSQL** | 복잡한 쿼리와 데이터 타입 지원에 강점이 있는 RDBMS. | 디스크 조각 영역을 회수하는 VACUUM과, SQL 뿐만 아니라 JSON을 이용해 데이터 접근 가능. | **금융 시스템**(예: 거래 내역 및 사용자 데이터 관리), **GIS 애플리케이션**(지리 공간 데이터 처리), **데이터 분석 플랫폼**(복잡한 쿼리와 통계 처리), **IoT 장치 데이터 관리**. |
| **MongoDB** | **도큐먼트** 기반 NoSQL DB. | Binary JSON 형태로 데이터가 저장되고 스키마 유연성이 높으므로, 비정형 빅데이터 처리에 적합. | **소셜 네트워크**(사용자 프로필 및 게시물 관리), **IoT 데이터 저장**(센서 데이터 처리), **로그 관리 시스템, 채팅 애플리케이션**(실시간 메시지 데이터 저장). |
| **Redis** | 키-값 저장소로, **인메모리** 기반의 NoSQL DB. | 데이터를 메모리에 저장하며, Pub/Sub 및 캐싱 기능을 지원. | **캐시 시스템**(예: API 응답 캐싱), **세션 저장소**(웹 애플리케이션 세션 관리), **실시간 통계 처리**(예: 게임 순위판, 실시간 사용자 수), **메시지 큐, 이벤트 스트리밍.** |

# 5. 인덱스 ⭐

### 인덱스

- **의미**: 데이터를 빠르게 검색하기 위해 생성하는 “데이터 구조”.
- **효율적인 이유**: B-Tree의 균형잡힌 구조와 트리 깊이의 대수확장성으로 인해, 검색 시간을 줄이고 디스크 I/O를 최소화했기 때문.
- **대수 확장성**: 검색/삽입/삭제 작업에서 “로그 시간복잡도”를 보장하여, 데이터 크기가 증가해도 거의 일정한 성능을 유지.

### 인덱스 최적화 기법

1. **비용:** “인덱스를 사용함으로써 절약되는 검색 비용”과 “인덱스 조회/수정 비용” 사이의 트레이드 오프를 고려해, 꼭 필요할 때만 설정해야 한다. 
2. **테스트**: 인덱스를 사용한 검색시간을 테스트를 통해 최소화해야 한다.
3. **복합 인덱스 설정의 우선순위**: 같음(==, equal) → 정렬 → 다중 값 출력(>, <) → 카디널리티(유니크한 값의 정도)

# 6. 조인

### 종류

Inner Join (교집합), Left Outer Join, Right Outer Join, Full Outer Join (합집합)

→ 레코드에 “join 조건 속성에 대한 값”이 없는 경우, null 값으로 출력된다. (단 Inner Join의 경우는 교집합에 해당되지 않으므로 아예 출력되지 않음)

### 원리 ⭐

1. **Nested Loop Join**:
    - 중첩 반복문 방식. 작은 데이터셋에서는 간단히 사용 가능하지만, 큰 데이터셋에서는 비효율적.
    - **인덱스**를 사용하면 내부 루프를 최적화하여 성능 향상 가능.
    - **O(M × N)** (M: 외부 테이블 크기, N: 내부 테이블 크기)
2. **Sort Merge Join**:
    - 양쪽 테이블을 정렬한 후, 정렬된 결과를 병합하여 조인 수행. 조인 키가 정렬되어 있을 경우 효율적.
    - 주로 정렬 기반 DBMS나, 데이터가 정렬된 경우에 사용.
    - **O(M log M + N log N + M + N)** (정렬 비용 + 병합 비용)
3. **Hash Join**:
    - 한 테이블의 데이터를 메모리의 해시 테이블에 저장한 뒤, 다른 테이블의 데이터를 해시 키로 검색. **동등(=) 조인**에서만 사용 가능하다.
    - 일반적으로 가장 빠르지만, 메모리 제약이 있다면 성능 저하 발생 가능.
    - **O(M + N)** (M: 메모리에 해시 테이블 빌드 비용, N: 해시 검색 비용).