# CS스터디 4회차 - DB

날짜: 2025년 1월 23일

# 1. DB 기본

### 용어

- **Entity**: 데이터를 저장하기 위한 실체로, 물리적 또는 개념적 대상. (예: 고객, 제품)
- **Relation(RDB - Table, NoSQL - Collection)**: 데이터를 저장하는 구조적 기본단위
- **Attribute**: Entity의 특징이나 속성을 나타내는 요소. (예: 이름, 나이)
- **Domain**: Attribute가 가질 수 있는 값의 집합. (예: 나이의 도메인은 0~120)

### Key

- 테이블 간의 관계를 명확히하고 “테이블 자체”의 인덱싱을 위한 장치.
- **슈퍼키**: 테이블에서 레코드를 **고유하게 식별**할 수 있는 속성. (**유일성** 만족)
- **후보키**: 기본키로 사용할 수 있는 모든 키. (**유일성 + 최소성** 만족)
- **기본키(PK)**: 테이블 내에서 각 레코드를 고유하게 식별하는 키. 중복 불가, NULL 불가.
- **대체키**: 후보키 중 기본키로 선택되지 않은 키.
- **외래키(FK)**: 다른 테이블의 기본키를 참조하는 키로, 테이블 간의 관계를 표현함.

# 2. ERD, 정규화

- **ERD**: Entity 간의 관계를 정의한 다이어그램. (시스템 요구사항 → ERD → DB 구축)
- **정규화**: DB 이상현상을 해결하고 데이터를 효율적으로 저장하기 위해, 테이블을 분리하는 과정.

|  | **의미** | **예시** |
| --- | --- | --- |
| **제1정규형** | 모든 속성이 **원자값**만을 가져야 한다. | '취미' 컬럼에 여러 개의 취미를 쉼표로 구분하여 저장하지 않고, 각 취미를 별도의 행으로 분리. |
| **제2정규형** | 제1정규형을 만족하면서, 기본키의 **부분 함수 종속성을 제거.** | 주문 테이블에서 “상품 ID” 기본키에 대해 “상품 정보”가 **부분 종속**될 경우 상품 테이블로 분리. |
| **제3정규형** | 제2정규형을 만족하면서, **이행적 함수 종속을 제거.** | 직원 테이블에서 “부서 ID”를 **통해** “부서 이름”을 **참조**할 경우, 부서 테이블로 분리함. |
| **보이스-코드 정규형 (BCNF)** | 제3정규형을 만족하면서 **모든 결정자가 후보키**여야 함. | **복합키 테이블**에서 한 속성이 “복합키 중 한 속성”을 결정하는 경우. |

# 3. 트랜잭션, 무결성

### 정의

- **트랜잭션**: 하나의 논리적 기능을 수행하는 여러 쿼리들을 묶은 작업 단위.
- **무결성(Integrity)**: 데이터의 정확성, 유효성을 유지하는 성질로서, 무결성이 유지되어야 데이터 값과 현실 세계의 실제 값이 일치함에 대한 신뢰가 생긴다. 트랜잭션이 ACID 속성을 준수해야만 무결성을 유지할 수 있다.

| Entity **Integrity** | 모든 테이블이 **PK 컬럼**을 가져야 하고, 그 컬럼은 빈 값을 허용하지 않는다. |
| --- | --- |
| Referential **Integrity** | 참조 관계의 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다. 이를 지키기 위해 **FK**에 **RESTRICTED**, **CASCADE**, **SET NULL** 등의 제약조건을 설정한다. |
| Domain **Integrity** | 컬럼의 값은 정의된 도메인에 속한 값이어야 한다. 이를 지키기 위해 **컬럼 타입** 및 **NOT NULL** 제약 조건을 설정한다. |

### Atomicity

- **의미**: 트랜잭션 내의 모든 쿼리가 완전하게 수행(**commit**)되어 DB에 영구 저장되거나, 중간에 이슈 발생시 트랜잭션 전체가 취소됨(**rollback**)을 보장하는 속성.
- **예시**: 은행 계좌 이체에서 “출금”과 “입금”이 모두 성공하거나, 모두 취소되는 경우.

### Consistency

- **의미**: 트랜잭션이 “유효한 논리적 상태”에서만 작업을 수행해야 하는 속성.
- **예시**: 계좌 잔액이 모자란 경우, 논리적으로 송금이 불가능.

### Isolation

- **의미**: 여러 트랜잭션이 동시에 실행될 때 서로 간섭하지 않아야 하는 속성.
- **예시**: 동시에 실행되는 “주문 생성”과 “재고 감소” 트랜잭션이 서로 영향을 미치지 않아야 한다.
- **트랜잭션 격리 수준⭐**

|  | **설명** | **발생 가능한 동시성 문제** | **특징 및 주의사항** |
| --- | --- | --- | --- |
| **SERIALIZABLE** (격리성, 데이터 일관성 높음) | 트랜잭션을 순차적 실행. | 없음 | 데이터 일관성이 완전히 보장하지만, 성능 저하가 클 수 있다. |
| **REPEATABLE READ**  | “동일” 트랜잭션 내에서 동일한 데이터를 읽으면 항상 동일한 결과를 보장. 즉 “다른” 트랜잭션은 **(레코드 추가는 가능하나) 값 수정은 불가.** | Phantom Read | Non-Repeatable Read를 방지. (MySQL 기본값) |
| **READ COMMITTED**  | 다른 트랜잭션이 “commit해야만” 조회 가능. | Phantom Read, Non-Repeatable Read | Dirty Read는 방지되지만, 동일 트랜잭션에서 조회 결과값이 달라질 수 있다. (PostgreSQL, 오라클 기본값) |
| **READ UNCOMMITTED** (동시성, 성능 높음) | 다른 트랜잭션이 “commit하지 않아도” 조회 가능. | Phantom Read, Non-Repeatable Read, Dirty Read | 성능은 좋지만, 데이터 일관성이 떨어질 수 있다. |
- **동시성 문제**
    - **Phantom Read**: 트랜잭션 작업 중 다른 트랜잭션이 **“레코드”**를 추가/삭제할 수 있어, 동일 트랜잭션 내에서 레코드 조회 결과가 달라질 수 있는 현상.
    - **Non-Repeatable Read**: 트랜잭션 작업 중 다른 트랜잭션이 **“데이터 값”**을 수정할 수 있어, 동일 트랜잭션 내에서 값 조회 결과가 달라질 수 있는 현상.
    - **Dirty Read**: 다른 트랜잭션이 **아직 커밋하지 않은** 데이터를 읽을 수 있어, 데이터 무결성이 지켜지지 않는 현상.

### Durability

- **의미**: 트랜잭션이 commit되었다면, 시스템 장애가 발생해도 결과가 유지되어야 하는 속성. Checksum(오류 정정), Journaling(commit 전 로깅), Rollback 등을 통해 보장된다.
- **예시**: 결제 완료 후 시스템 장애가 발생한 경우, DB를 복구하면 결제 기록이 남아 있어야 한다.

### 스프링에서 트랜잭션을 적용하는 방법⭐

스프링의 [**@transactional**](https://github.com/transactional) 어노테이션을 클래스나 메서드에 선언하여 트랜잭션 관리자를 적용할 수 있다. 여기에 아래의 다양한 속성과 옵션을 설정하여 트랜잭션의 동작을 제어할 수 있다.

- **전파 방식(Propagation)**
    
    ```java
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void method() {
        // 항상 새로운 트랜잭션 생성
    }
    ```
    
    - REQUIRED (기본값): 기존 트랜잭션이 있으면 해당 트랜잭션을 사용하고, 없으면 새 트랜잭션을 생성.
    - REQUIRES_NEW: 항상 새로운 트랜잭션을 생성.
    - SUPPORTS: 기존 트랜잭션이 있으면 사용하고, 없으면 트랜잭션 없이 실행.
    - 기타 옵션: MANDATORY, NOT_SUPPORTED, NEVER, NESTED.
    
- **격리 수준(Isolation)**
    
    ```java
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void method() {
        // REPEATABLE_READ 격리 수준 적용
    }
    ```
    
    명시적으로 설정하지 않으면, 스프링은 **데이터베이스의 기본 격리 수준을 따른다.** 예컨대 **MySQL(InnoDB**)은 REPEATABLE READ, **Oracle, PostgreSQL, SQL Server** 등은 READ COMMITTED 격리수준이 적용된다.
    
    - SERIALIZABLE: 가장 엄격한 격리 수준으로 동시성을 제한.
    - REPEATABLE_READ: 같은 데이터를 여러 번 읽어도 동일한 결과를 보장.
    - READ_COMMITTED: 커밋된 데이터만 읽음.
    - READ_UNCOMMITTED: 커밋되지 않은 데이터를 읽음(Dirty Read).
    
- **롤백 조건 설정**
    
    ```java
    @Transactional(rollbackFor = RuntimeException.class)
    public void method() {
        // RuntimeException 발생 시 롤백
    }
    ```
    
    - rollbackFor: 특정 예외 발생 시 롤백.
    - noRollbackFor: 특정 예외 발생 시 롤백하지 않음.

# 4. DB의 종류

| ⭐ | **특징** | **강점** |
| --- | --- | --- |
| **RDB** | 고정된 스키마를 가지며, 관계를 기반으로 **“테이블”** 형식 데이터를 저장. | **데이터 일관성**이 높음. **조인** 등 복잡한 데이터 처리가 필요할 때 적합. |
| **NoSQL** | 유연한 스키마를 가지며, **“컬렉션”** 형식으로 비정형 데이터를 저장. | **확장성**이 뛰어남. 데이터 수정이 빈번할 때보다는 **빅데이터를 빠르게 삽입**할 때 유리. |

|  | **설명** | **특징** | **활용예시** |
| --- | --- | --- | --- |
| **MySQL** | 스토리지 엔진을 쉽게 바꿀수 있고, 트랜잭션 처리에 강점을 가지는 RDBMS. | 모듈식 아키텍처로 설계되어 있고, SQL 쿼리를 통해 데이터 조작을 수행. | **전자상거래 플랫폼**(예: 상품, 주문 데이터 관리), **블로그 시스템**(예: 게시글 및 댓글 관리), **고객 관리 시스템**(CRM), **인벤토리 관리 애플리케이션**. |
| **PostgreSQL** | 복잡한 쿼리와 데이터 타입 지원에 강점이 있는 RDBMS. | 디스크 조각 영역을 회수하는 VACUUM과, SQL 뿐만 아니라 **JSON**을 이용해 데이터 접근 가능. | **금융 시스템**(예: 거래 내역 및 사용자 데이터 관리), **GIS 애플리케이션**(지리 공간 데이터 처리), **데이터 분석 플랫폼**(복잡한 쿼리와 통계 처리), **IoT 장치 데이터 관리**. |
| **MongoDB** | **도큐먼트** 기반 NoSQL DB. | **Binary JSON** 형태로 데이터가 저장되고 스키마 유연성이 높으므로, 비정형 빅데이터 처리에 적합. | **소셜 네트워크**(사용자 프로필 및 게시물 관리), **IoT 데이터 저장**(센서 데이터 처리), **로그 관리 시스템, 채팅 애플리케이션**(실시간 메시지 데이터 저장). |
| **Redis** | 키-값 저장소로, **인메모리** 기반의 NoSQL DB. | 데이터를 **메모리**에 저장하며, **Pub/Sub** 및 **캐싱** 기능을 지원. | **캐시 시스템**(예: API 응답 캐싱), **세션 저장소**(웹 애플리케이션 세션 관리), **실시간 통계 처리**(예: 게임 순위판, 실시간 사용자 수), **메시지 큐, 이벤트 스트리밍.** |

# 5. 인덱스

### 인덱스

- **의미**: 데이터를 빠르게 검색하기 위해 생성하는 “데이터 구조”.
- **효율적인 이유**: B-Tree의 균형잡힌 구조와 트리 깊이의 대수확장성으로 인해, 검색 시간을 줄이고 디스크 I/O 횟수를 최소화했기 때문.
- **대수 확장성**: 검색/삽입/삭제 작업에서 “로그 시간복잡도”를 보장하여, 데이터 크기가 증가해도 거의 일정한 성능을 유지.

### 인덱스를 사용하기 좋은 경우⭐

무분별한 인덱스 사용은 오히려 성능을 저하시킬 수 있으므로, 아래 케이스와 같은 경우에만 생성하는 것이 좋다.

- **자주 조회되는 컬럼** (사용자 ID, 이메일 주소, 상태 플래그 등):
    
    읽기 작업(SELECT)이 쓰기 작업(INSERT, UPDATE, DELETE)보다 많은 경우에 사용하기 좋다.
    
    → **근거**: 인덱스는 데이터를 효율적으로 탐색할 수 있도록 도와 Full Table Scan을 방지한다. 그러나 쓰기 작업에서는 인덱스도 추가로 갱신해야 하므로 성능에 영향을 미칠 수 있다.
    
- **ORDER BY, GROUP BY, JOIN, DISTINCT에서 사용되는 컬럼**:
    
    정렬된 데이터를 빠르게 찾을 수 있도록 도와주고, 조인할 때 테이블 간 매칭 성능이 개선된다.
    
    → **근거**: 인덱스는 데이터가 정렬된 구조(B-Tree 등)로 저장되어 있어 정렬 및 조합 작업의 속도를 크게 높인다.
    
- **테이블 크기가 큰 경우**:
    
    테이블의 크기가 클수록 데이터를 검색하거나 필터링할 때 비용이 증가한다.
    
    → **근거**: 인덱스는 대량의 데이터를 효율적으로 탐색하도록 설계되어, 특히 대규모 테이블에서 검색 성능을 극적으로 개선한다.
    
- **중복도가 낮은 컬럼**:
    
    '성별'처럼 값의 종류가 적고 중복도가 높은 경우 인덱스 효과가 적다.
    
    → **근거**: 중복도가 높은 컬럼은 인덱스를 통해 필터링할 수 있는 데이터의 범위가 제한되기 때문에, 결과적으로 전체 데이터를 스캔하는 것과 큰 차이가 없다.
    
- **외래키로 지정된 컬럼**:
    
    부모 테이블과의 관계를 조회하거나 삭제할 때 성능이 향상된다.
    
    → **근거**: 외래키 제약 조건은 부모 테이블을 참조하는 작업이 많으므로, 인덱스를 통해 참조 무결성 체크와 관련 작업을 빠르게 수행할 수 있다.
    

### 인덱스 최적화 기법

1. **비용:** “인덱스를 사용함으로써 절약되는 검색 비용”과 “인덱스 조회/수정을 위해 추가로 드는 비용” 사이의 트레이드 오프를 고려해, 꼭 필요할 때만 설정해야 한다. 
2. **테스트**: 인덱스를 사용한 검색시간을 테스트를 통해 최소화해야 한다.
3. **복합 인덱스 설정의 우선순위**: 같음(==, equal) → 정렬 → 다중 값 출력(>, <) → 카디널리티(유니크한 값의 정도)

# 6. 조인

### 종류

Inner Join (교집합), Left Outer Join, Right Outer Join, Full Outer Join (합집합)

→ 레코드에 “join 조건 속성에 대한 값”이 없는 경우, null 값으로 출력된다. (단 Inner Join의 경우는 교집합에 해당되지 않으므로 아예 출력되지 않음)

### 원리 ⭐

1. **Nested Loop Join**:
    - 중첩 반복문 방식. 작은 데이터셋에서는 간단히 사용 가능하지만, 큰 데이터셋에서는 비효율적.
    - **인덱스**를 사용하면 내부 루프를 최적화하여 성능 향상 가능.
    - **O(M × N)** (M: 외부 테이블 크기, N: 내부 테이블 크기)
2. **Sort Merge Join**:
    - 양쪽 테이블을 정렬한 후, 정렬된 결과를 병합하여 조인 수행. 조인 키가 정렬되어 있을 경우 효율적.
    - 주로 정렬 기반 DBMS나, 데이터가 정렬된 경우에 사용.
    - **O(M log M + N log N + M + N)** (정렬 비용 + 병합 비용)
3. **Hash Join**:
    - 크기가 더 작은 테이블의 데이터를 메모리의 해시 테이블로 저장한 뒤(**build**), 다른 테이블의 데이터를 해시 테이블에서 key로 검색(**probe**). **동등(=) 조인**에서만 사용 가능하다.
    - 일반적으로 가장 빠르지만, 메모리 제약이 있다면 성능 저하 발생 가능.
    - **O(M + N)** (M: 메모리에 해시 테이블 빌드 비용, N: 해시 검색 비용).