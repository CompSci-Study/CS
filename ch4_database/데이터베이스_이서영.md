## 데이터베이스의 기본

- DB(데이터베이스): 일정 규칙을 통해 구조화된 데이터의 모음. 실시간 접근, 동시 공유 가능
- DBMS (DB Management System): DB를 제어하고 관리하는 시스템. Query language 통해 CRUD
- DB ↔ DBMS ↔ 프로그램
- 엔티티: 여러 속성을 지닌 명사. 필요에 맞게 속성 조정
    - 강한 엔티티: 혼자 존재 가능
    - 약한 엔티티: 타엔티티 종속적. 혼자 존재 불가능
- 릴레이션: = 테이블. 정보를 구분해 저장하는 단위
    - RDBMS: 레코드 → 테이블 → DB
    - NoSQL: 도큐먼트 → 컬렉션 → DB
- 속성 (attribute): 고유한 이름을 가진 정보
- 도메인: 속성들이 가지는 값의 집합
- 필드: 속성을 정의한 column
- 레코드: 필드의 값을 가진 테이블의 row 단위 데이터
- 테이블간 관계
    - 1:1
    - 1:N
    - N:M ⇒ 실제로는 1:N + 1:M 으로 두 테이블로 나눠서 관리

### 필드 타입

- 숫자: tinyint ~ bigint
- 날짜: Date(날짜만), datetime(시간 포함), timestamp(날짜 제약, UTC 변경) 등
- 문자: char(고정), varchar(가변), text(큰 문자열), blob(바이너리, 큰 데이터), enum(정해진 것 중 1개 선택), set(enum 비슷, 여러 데이터 선택 가능)

### 키

- 기본키 (Primary Key)
    - 유일성: 중복되지 않아야 함
    - 최소성: 키를 구성하기 위한 속성의 수가 최솟값
    - 자연키: 자연적으로 존재하며 PK 조건을 만족하는 속성을 사용
    - 인조키: 인위적으로 식별자 부여
- 외래키 (Foreign Key)
    - 다른 테이블의 기본키 참조, 중복 가능
- 후보키 (Candidate Key)
    - 기본키의 후보들. 유일성 O, 최소성 O
- 대체 키 (Alternate Key)
    - 기본키를 지정하고 남은 후보키
- 슈퍼 키 (Super Key)
    - 유일성 O

## ERD와 정규화

- ERD: 릴레이션 간의 관계를 정의한 구조도. 정형 데이터에 적합
- 정규화 과정: DB 이상현상 해결, 저장 공간 효율화 등의 목표로 릴레이션 분리
- 정규형 원칙: 더 좋은 구조, 중복성 감소,독립적 관계 → 별개의 릴레이션, 릴레이션 → 독립적 표현

- 제 1정규형
    - 모든 도메인이 더이상 분해될 수 없어야 함 (Atomic)
    - ⇒ 각 레코드는 속성 당 한개의 값만 지니고 있어야 함
- 제 2정규형
    - 부분 함수 종속성 제거
    - ⇒ PK에 속하지 않는 속성은 PK가 포함한 모든 속성에 종속적이어야 한다. 그렇지 않을 경우 해당 속성이 dependent한 속성으로 릴레이션을 분리한다.
- 제 3정규형
    - 이행적 함수 종속 (Transitive Functional Dependency) 분해
    - 한 테이블 내에서 속성 간 A → B, B → C 가 만족할 때 A → C 이므로 A,B 테이블과 B,C 테이블로 분해
    - BCNF (보이스-코드 정규형)
        - 제 3정규형에서 A → B일 때 모든 A가 후보키가 되도록 하는 상태

## 트랜잭션과 무결성

### 트랜잭션

하나의 논리적 기능을 수행하기 위한 작업의 단위. ACID 특징을 가진다

- Atomicity (원자성)
    - 0 or 1. 트랜잭션과 관련된 일이 모두 수행되거나/모두 되지않을 것
    - 트랜잭션을 커밋 후 롤백하면 커밋의 일정 내역만 반영된 상태일 수 없음
        - 커밋: 트랜잭션의 내용을 영구적으로 저장하는 것 (커밋 시작부터 종료까지가 트랜잭션)
        - 롤백: DB를 커밋 전 상태로 돌리는 것
- Consistency (일관성)
    - DB의 모든 데이터는 유효하며 데이터 변경은 허용된 규칙을 따라야 함.
- Isolation (격리성)
    - 트랙잭션끼리는 격리되어 서로 간섭할 수 없음
    - 격리 수준 4단계
        - Serializable
            - 모든 트랜잭션을 격리해 순차적으로 진행
        - Repeatable_read
            - 다른 트랜잭션이 수정한 행을 수정할 수 없으나 추가는 가능
            - 문제점: 팬텀 리드
        - Read_committed
            - 다른 트랜잭션이 커밋 완료한 정보만 조회 가능
            - 다른 트랜잭션이 수정한 행을 수정 가능
            - 문제점: 팬텀 리드, 반복 가능하지 않은 조회
        - Read_uncommitted
            - 커밋되기 이전의 수정도 조회 가능
            - 문제점: 팬텀 리드, 반복 가능하지 않은 조회**,** 더티 리드
    - 문제점 3가지
        - 팬텀 리드
            - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 다른 조회 결과를 보이는 현상
            - 트랜잭션 중 다른 트랜잭션에서 행 추가/행 수정 시 발생
        - 반복 가능하지 않은 조회 (Non-repeatable Read)
            - 한 트랜잭션 내에서 같은 행을 조회했을 때 다른 결과를 보이는 현상
            - 트랜잭션 중 다른 트랜잭션에서 행 수정 시 발생
        - 더티 리드
            - 한 트랜잭션 내에서 다른 트랜잭션에서 수정했으나 커밋되지 않은 행을 읽는 현상
- Durability (지속성)
    - 성공적으로 수행된 트랜잭션은 DB에 영구적으로 반영되어야 한다. ⇒ 원 상태로 복구가 가능하다

### 데이터의 무결성

- 개체 무결성: PK는 빈 값이 없어야 함
- 참조 무결성: 참조 관계의 두 테이블의 데이터는 일관된 값을 유지해야 함
- NULL 무결성: 속성값이 Nullable이 아닌 경우 Null 불가능

## 데이터베이스의 종류

### 관계형 데이터베이스 (RDBMS)

- 행과 열을 가지는 테이블 형식의 데이터를 저장하는 DB
- MySQL (쿼리 캐시 기능), PostgreSQL (디스크 영역 회수 기능, JSON을 통한 조작 기능), Oracle 등

### NoSQL DB

- Not Only SQL ⇒ SQL을 사용하지 않음
- MongoDB
    - JSON으로 데이터 접근, Binary JSON으로 데이터 저장
    - 스키마 정할 수 있음
    - 도큐먼트 (= 레코드) 생성 시마다 유니크한 값 생성
- redis
    - 키-값 기반의 DB (string 타입 사용)
    - pub/sub, 캐싱 계층 등

## 인덱스

데이터를 빠르게 찾을 수 있도록 하는 장치

- B-tree
    - 인덱스를 이루는 자료 구조
    - 루트 → 브랜치 → 리프 노드
    - ‘값과 같거나 클 때’를 기준으로 트리 탐색
- 대수확장성: 트리의 깊이가 리프노드 수(전체 데이터 수) 보다 매우 느리게 성장하는 것
- MySQL Index
    - 클러스터형: 테이블당 1개. PK 설정 시 생성, 혹은 unique not null 옵션으로 생성
    - 세컨더리: create index … 으로 생성 ← 클러스터형의 보조 인덱스 (검색 attr. 많으면)
- MongoDB
    - 도큐먼트 생성 시 ObjectId 자동 생성 ← 이게 PK
    - 세컨더키도 설정 가능
- 인덱스 최적화
    - 데이터의 조회/수정이 잦을 수록 많은 인덱스 사용은 비효율적임
        - 인덱스 사용시 항상 2회 탐색됨. (인덱스 리스트 → 데이터 테이블)
        - 테이블 수정 시 인덱스도 수정해야 함.
    - 항상 테스트하며 조회 시간을 최소화 할 것
    - 복합 인덱스 생성 순서 ⇒ 카디널리티(값이 유니크한 정도)가 높은 순으로 생성
        - 쿼리에 == 혹은 equal이 있는 필드
        - 정렬에 쓰이는 필드
        - <, > 등다중 레코드를 출력하는 필드

## Join의 종류

Join: 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것, NoSQL의 Join은 성능이 떨어지므로 Join이 많으면 RDBMS 사용

### Inner Join

- 내부 조인
    - 왼쪽, 오른쪽 테이블에 일치하는 행이 있는 경우 해당 부분만 표시
    - 두 테이블의 교집합

### Outer Join

- Left Outer Join (왼쪽 조인)
    - 왼쪽 테이블을 기준으로 모든 행을 포함한 결과 생성. 오른쪽 테이블에 해당 행이 없으면 null
- Right Outer Join (오른쪽 조인)
    - 오른쪽 테이블을 기준으로 모든 행을 포함한 결과 생성. 왼쪽 테이블에 해당 행이 없으면 null
- Full Outer Join (합집합 조인)
    - 양쪽 테이블 모두 기준으로 모든 행 포함. 일치하는 항목이 없으면 null

## Join의 원리

- 중첩 루프 조인
    - 중첩 for 문과 같이 행을 하나씩 읽어나가며 비교
- 정렬 병합 조인
    - 각 테이블을 조인할 필드 기준으로 정렬 후 조인
    - 조인 조건으로 >, < 등 범위 비교 연산자 존재 시
- 해시 조인
    - 해시 체이블 기반 조인, = 조인에만 사용 가능
    - 빌드 단계
        - 입력 테이블 중 크기가 작은 테이블을 기반으로 메모리 내 해시테이블 생성
        - 조인에 사용되는 필드가 해시 테이블의 키
    - 프로브 단계
        - 레코드 읽기 시작, 다른 테이블의 필드 값을 키로 해시테이블 조회
