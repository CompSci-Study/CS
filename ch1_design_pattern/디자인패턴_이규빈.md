# CS스터디 1회차 - 디자인 패턴

날짜: 2025년 1월 2일

## 라이브러리 vs. 프레임워크

- **공통점**: 공통으로 사용될 수 있는 특정 기능을 모듈화한 것. 개발 효율성을 높이고 재사용 가능한 코드를 제공.
- **차이점**: 라이브러리는 “개발자”가 호출하지만, 프레임워크는 “자체적으로” 개발자의 코드를 호출(예: 스프링 프레임워크의 IoC 컨테이너).
    
    이에 따라 라이브러리는 **“유연성”**이 높지만, 구현 대상이 많아 번거로울 수 있다.
    
    반면, 프레임워크는 제한된 구조와 규칙에 따라 개발해야 하지만, 자체적으로 처리하는 사항이 많아 **“통일성 및 개발생산성”**면에서 유리하다.
    

## 디자인 패턴

- **정의**: 프로그램 설계시 자주 발생하는 문제점을 “규약” 형태로 만들어 놓은 것
- **장점**: 자질구레한 객체 단위가 아니라, “패턴 단위”로 개발하고 소통 가능. 이에 따라 코드의 유연성, 재사용성이 향상됨.

## [Singleton 패턴](https://velog.io/@kevinlee94/Singleton-%ED%8C%A8%ED%84%B4-%ED%95%98%EB%82%98%EB%BF%90%EC%9D%B8-%ED%8A%B9%EB%B3%84%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0)

- **정의**: 클래스의 인스턴스를 단 하나만 생성하고, 전역적으로 접근 가능하게 하는 패턴.
- **장점**: 상태 일관성 유지, 메모리 절약.
- **단점**:
    - TDD 할때 단위 테스트가 어렵다.
    - 모듈 간 결합도가 높아진다. → DI를 이용한 디커플링으로 해결
    - 멀티스레드 환경에서 동기화 문제가 발생할 수 있다. → synchronized, 이중 검증 잠금(DCL)으로 해결
- **활용사례:**
    - **Spring IoC 컨테이너의 Bean 객체 관리**: 전체 애플리케이션에서 동일한 객체 참조 가능. 객체 생성 비용 절약. 메모리 효율성 향상.
    - **DB 커넥션 풀(SpringBoot의 HikariCP 등):** 리소스 효율성, DB 부하 최적화.
    - **Logger 객체(SLF4J 등):** 애플리케이션 전반에 걸쳐 일관된 로깅 환경을 제공.

## Factory 패턴 ([Factory Method](https://velog.io/@kevinlee94/Factory-%ED%8C%A8%ED%84%B4-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%EC%BA%A1%EC%8A%90%ED%99%94%ED%95%B4%EC%84%9C-%EC%9C%A0%EC%97%B0%EC%84%B1-%ED%99%95%EB%B3%B4) / [Abstract Factory](https://velog.io/@kevinlee94/Abstract-Factory-%ED%8C%A8%ED%84%B4-))

- **정의**: 객체 생성 로직을 별도의 팩토리 클래스로 분리하여 캡슐화하는 패턴.
- **장점**: 클라이언트 코드에서 객체 생성 부분을 분리해, 유연성 · 확장성 제공.
- **단점**: 클래스 수가 증가. 코드가 복잡해짐.
- **적용되는 객체지향 원칙**: 개방-폐쇄 원칙(OCP), 의존성 역전 원칙(DIP).
- **활용사례**:
    - **Spring의 Bean Factory:** Bean 객체 생성 로직을 따로 떼내 캡슐화하여 BeanFactory에 위임 → 애플리케이션 흐름의 제어권을 개발자가 아닌 "스프링”이 갖게 됨(IoC; Inversion of Control)
    - **JDBC Driver Manager:** DB 연결 객체를 생성 및 관리

## [Strategy 패턴](https://velog.io/@kevinlee94/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80-%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4Strategy-Pattern)

- **정의**: 알고리즘을 캡슐화하여 런타임 중에 교체 가능하도록 만드는 패턴.
- **장점**: 알고리즘의 확장성과 유지보수성 향상.
- **단점**: 전략 클래스가 많아져 코드가 복잡해질 수 있음.
- **적용되는 객체지향 원칙**: 인터페이스를 통해 동작을 캡슐화.
- **활용사례**:
    - **Passport(인증 미들웨어 라이브러리):** 인증 전략을 LocalStrategy 또는 OAuth 등으로 변경 가능
    - **Java의 Comparator:** 비교 전략을 런타임 중 교체하여 정렬 방식을 변경 가능.
    - **Spring의 AuthenticationManager:** 인증 방식을 동적으로 변경 가능.

## [Observer 패턴](https://velog.io/@kevinlee94/Observer-%ED%8C%A8%ED%84%B4-%EA%B5%AC%EB%8F%85%EC%9E%90%EB%93%A4%EC%97%90%EA%B2%8C-%EC%83%81%ED%83%9C%EB%B3%80%EA%B2%BD-%EC%95%8C%EB%A6%AC%EA%B8%B0)

- **정의**: 서브젝트의 상태 변경을 옵저버들에게 통지하는 “일대다 의존관계”를 정의한 패턴.
- **장점**: 주체와 관찰자 간의 느슨한 결합(Loose Coupling).
- **단점**: 관찰자가 많아질수록 성능 저하 가능.
- **활용사례**:
    - **트위터**: 팔로워에게 알림 기능
    - **Java의 Observable:** MVC 패턴에 적용되어 Model이 서브젝트, View가 옵저버로 기능
    - **JS의 EventListener:** DOM 요소가 서브젝트, addEventListener로 추가된 화살표 함수 객체가 옵저버로 기능
    - **RxJava:** 비동기 데이터 흐름을 관찰하고 처리하는 리액티브 프로그래밍 라이브러리.

## Proxy 패턴

- **정의**: 실제 객체에 대한 접근을 제어하거나 대리 역할 객체를 사용하는 패턴.
- **장점**: 접근 제어, 성능 최적화, 로깅 등 다양한 기능 제공.
- **단점**: 복잡성이 증가하고 간접 호출로 인한 성능 저하 가능.
- **적용되는 객체지향 원칙**: 개방-폐쇄 원칙(OCP), 의존성 역전 원칙(DIP).
- **활용사례**:
    - **Spring AOP:** 메서드 호출 전후에 부가 기능을 제공하는 프록시 객체 생성.
    - **Hibernate Lazy Loading:** 필요한 시점에 DB 엔티티를 로드하기 위한 가상 프록시 객체 사용.
    - **Proxy 서버:** 주로 서버 앞단에 두고 요청 라우팅, 캐싱, 로깅, 데이터 분석 등을 먼저 하는 서버. (NginX, CloudFlare 등)

## Iterator 패턴

- **정의**: 컬렉션의 내부 구조를 노출하지 않고 요소를 순회할 수 있는 패턴.
- **장점**: 개별 컬렉션의 내부 구현 방식과 상관없이, 일관된 순회 가능.
- **단점**: 단일 순회 방식만 지원할 수 있음.
- **적용되는 객체지향 원칙**: 단일 책임 원칙(SRP).
- **활용사례**: Java의 Iterator, Enumeration

## MVC 패턴

- **정의**: 애플리케이션을 모델(Model), 뷰(View), 컨트롤러(Controller)로 분리하는 패턴.
- **장점**: 모듈화와 유지보수성 향상.
- **단점**: 복잡성이 증가하고 구성 요소 간 통신 부담.
- **적용되는 객체지향 원칙**: 단일 책임 원칙(SRP), 분리된 관심사.
- **활용사례**: Spring MVC

## MVVM 패턴

- **정의**: 모델(Model), 뷰(View), 뷰모델(ViewModel)을 분리하여 “데이터 바인딩”을 통해 연결하는 패턴.
- **장점**: 데이터와 UI 간의 자동 동기화로 생산성 향상.
- **단점**: 데이터 바인딩이 복잡하거나 디버깅이 어려울 수 있음.
- **적용되는 객체지향 원칙**: 단일 책임 원칙(SRP), 의존성 역전 원칙(DIP).
- **활용사례**: Vue.js, Android Jetpack

## 프로그래밍 패러다임

- **선언형(함수형) vs 명령형**: 선언형은 “결과”를 기술하고, 명령형은 “절차”를 명시한다.
- **객체지향형 vs 절차지향형**: 객체지향형은 “객체 간 상호작용”에 초점을 두고, 절차지향형은 “순차적 실행”에 중점을 둔다.

## 객체지향 프로그래밍 (OOP)

- **캡슐화**: 데이터를 숨기고, 접근을 제한하여 **안전성과 유연성**을 높인다.
- **상속**: 기존 클래스의 **특성을 재사용**하여 새로운 클래스를 생성한다.
- **추상화**: 공통 속성과 동작을 추출해 **간결하고 유연한 설계**를 한다.
- **다형성**: 동일한 인터페이스로 **다양한 구현**을 처리한다.
    - **Overloading**: “같은 이름”의 메서드를 매개변수에 따라 다르게 정의한다.
    - **Overriding**: 상속받은 메서드를 재정의하여 “동작을 변경”한다

## 객체지향 설계 원칙 (SOLID)

- **단일책임 원칙(SRP)**: 클래스는 하나의 책임만 가져야 한다.
- **개방-폐쇄 원칙(OCP)**: 기존 코드는 수정하지 않고 확장할 수 있어야 한다.
- **리스코프 치환 원칙(LSP)**: 자식 클래스는 부모 클래스를 대체해도 문제없이 동작해야 한다.
- **인터페이스 분리 원칙(ISP)**: 클라이언트는 자신이 사용하는 메서드만 알게 해야 한다.
- **의존 역전 원칙(DIP)**: 고수준 모듈은 저수준 모듈에 의존하지 않고, “추상화”에 의존해야 한다.
