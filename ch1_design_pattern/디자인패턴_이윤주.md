# 디자인 패턴

<aside>
💡

**디자인 패턴이란?**

프로그램을 설계할 때 발생했던 문제점들을 **객체 간의 상호 관계 등**을 이용하여 해결할 수 있도록 **하나의 “규약” 형태**로 만들어 놓은 것

</aside>

## 1) 싱글톤 패턴 Singleton pattern

<aside>
💡

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

데이터베이스 연결 모듈에 많이 사용

</aside>

- 장점 : 하나의 인스턴스를 여러 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성하는 비용이 줄어든다
- 단점 : 의존성이 높아진다. TDD 에 어려움이 있다. 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기 어렵다.

## 2) 의존성 주입 DI, Dependency Injection

싱글톤 패턴은 모듈 간의 결합을 강하게 만들 수 있다는 단점이 있다.

의존성 주입을 통해 모듈간의 결합을 조금 더 느슨하게 만들어 해결할 수 있다.

메인 모듈이 직접 하위 모듈에 대한 의존성을 주지 않고, 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 **간접적으로 의존성을 주입**하는 방식

⇒ **의존성이 떨어지게 된다 = 디커플링이 된다**

참고) 의존성(=종속성) : A가 B에 의존성이 있다 = B의 변경 사항에 대해 A 또한 변해야 된다.

## 2) 팩토리 패턴 Factory pattern

<aside>
💡

객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴

상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고,

하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

</aside>

- 장점
  - 내부적으로 인스턴스를 만드는 코드를 수정하지않고 새로운 인스턴스를 다양한 방법으로 확장할 수 있음
  - 객체의 일관성을 향상 시키고 코드가 간결해진다
  - 확장성 있는 프로젝트 구성에 용이하다
- 단점
  - 클래스가 많아진다 또한 클래스 계층도 커질 수 있다

## 3) 전략 패턴 Strategy pattern, 정책 패턴 Policy pattern

<aside>
💡

전략 패턴, 정책 패턴이라고도 하며,

객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 **“전략”**이라고 부르는

**“캡슐화한 알고리즘”**을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

</aside>

- 장점
  - 요구사항이 변경되었을 때 기존의 코드를 변경하지 않아도 되고, **컨텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점**
  - 새로운 전략에 대해서는 새로운 클래스를 통해 관리하기 때문에 개방-폐쇄 원칙(OCP, Open-Closed Principle)을 준수할 수 있다.
- 단점
  - 모든 상황에서 전략패턴이 사용되는 것은 유용하지 않다. 컨텍스트에 적용되는 알고리즘이 하나이거나 두개인 경우는 분기를 타는 것이 편한 경우도 있다.

## 4) 옵저버 패턴 Observer pattern

<aside>
💡

주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴

어떤 객체의 변경 사항이 발생하였을 때 이와 연관된 객체들에게 알려주는 디자인 패턴

</aside>

- 주체 : 객체의 상태 변화를 보고 있는 관찰자 (주체와 객체를 따로 두지 않고 객체 기반으로 구축하기도 함)
- 옵저버들 : 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 추가 변화 사항이 생기는 객체들
- 주체와 옵저버의 관계는 1:1이 될 수도 있고 1:N이 될 수 있다.
- **장점**
  - 실시간으로 한 객체의 변경사항을 다른 객체에 전파할 수 있다.
  - 느슨한 결합으로 시스템이 유연하고 객체 간의 의존성을 제거할 수 있다.
- **단점**

  - 너무 많이 사용하게 되면, 상태 관리가 힘들 수 있다
  - 데이터 배분에 문제가 생기면 자칫 큰 문제로 이어질 수 있다.

- 사용하는 상황: 이벤트 기반 시스템, MVC 패턴에도 사용됨
- 옵저버 패턴을 활용한 서비스 : 트위터
  - 팔로우 한 주체의 포스팅에 대한 알림이 팔로워에게 알려줌

### Vue.js 3.0의 옵저버 패턴

Vue3에서 ref나 reactive로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경되는데, 자바스크립트의 프록시 객체를 이용한 옵저버 패턴을 이용하여 구현한 것이다.

참고) 프록시(proxy) 객체 : 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체를 뜻하며, 자바스크립트에서 프록시 객체는 두 개의 매개변수를 가진다.

(target: 프록시할 대상, handler: target 동작을 가로채고 어떠한 동작을 할 것인가 설정되어 있는 함수)

참고) DOM Document Object Model : 문서 객체 모델, 웹 브라우저 상의 화면을 이루고 있는 요소들을 지칭한다.

## 5) 프록시 패턴 Proxy pattern 과 프록시 서버

<aside>
💡

대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴

이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다.

⇒ 프록시 객체, 프록시 서버로 활용됨

</aside>

- 장점
  - 사이즈가 큰 객체가 로딩되기 전에도 프록시 객체를 통해 참조할 수 있다.
    - 컴파일 과정에서 문제가 발생하지 않는다.
  - 실제 객체 접근 과정에서 사전 처리를 적용할 수 있다.
    - 로깅, 시간 측정, 캐싱, 흐름 제어 등
- 단점
  - 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있다.
  - 로직이 난해해져 가독성이 떨어질 수 있다.
- 활용 이유
  - 지연로딩
    - 만약 프록시 패턴이 적용되지 않은 프로젝트일 경우, 특정 객체가 다루는 데이터의 크기가 크면 **로드 과정에서 상당 시간이 소요**될 수 있다.
    - 이러한 상황에서 프록시 객체로 껍데기만 동일하게 만들어 두면, **실제로 해당 객체가 활용되기 전까지는 시간이 소요되지 않는다.**
  - 흐름 제어
    - 객체를 사용하는 측(Client)과 객체 사이에 대리인을 두어 흐름을 제어한다.

### 프록시 서버

<aside>
💡

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램

</aside>

- nginx : 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버
  ⇒ nginx를 Node.js 서버 앞단의 프록시 서버로 활용함
- CloudFlare : 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스
  ⇒ CloudFlare를 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 활용함

참고) CDN : Content Delivery Network, 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크. 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드 하는 시간을 줄일 수 있다.

### CORS와 프런트엔드의 프록시 서버

CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘

참고) 오리진 : 프로토콜, 호스트이름, 포트 조합 (ex) https://127.0.0.1:3000)

CORS 에러를 해결하기 위해 프런트엔드에서 프록시서버를 만들기도 한다.

프런트엔드 127.0.0.1:3000 테스팅

백엔드 서버 127.0.0.1:12010

이라면 포트 번호가 다르기 때문에 CORS 에러가 난다.

⇒ 이때 프록시 서버를 둬서 프런트 엔드 서버에서 요청되는 오리진을 127.0.0.1:12010 으로 바꾸면 해결된다.

## 6) 이터레이터 패턴 Iterator pattern

<aside>
💡

이터레이터(iterator)를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴

순회할 수 있는 여러 가지 자료형의 구조와 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

</aside>

- 장점
  - 집합체 클래스의 응집도를 높여준다.
  - 집합체 내에서 어떤 식으로 일이 처리되는지 알 필요 없이, 집합체 안에 들어있는 모든 항목에 접근 할 수 있게 해준다. (추상화)
  - 모든 항목에 일일이 접근하는 작업을 컬렉션 객체가 아닌 이터레이터 객체에서 맡게 된다. 이렇게 하면, 집합체의 인터페이스 및 구현이 간단해질 뿐만 아니라, 집합체에서는 반복 작업에서 손을 떼고 원래 자신이 할 일에만 전념할 수 있다.
- 단점
  - 단순한 순회를 구현하는 경우 클래스만 많아져 복잡도가 증가할 수 있다.

## 7) 노출모듈 패턴 Revealing module pattern

<aside>
💡

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴

자바스크립트는 private, public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되기 때문에 노출모듈 패턴을 통해 private, public 접근 제어자를 구현하기도 한다.

</aside>

- 노출모듈 패턴을 기반으로 만든 자바스크립트 모듈 방식으로는 CJS(CommonJS) 모듈 방식이 있다.
- 장점
  - 개발자에게 깔끔한 접근 방법을 제공
  - **_private 데이터 제공_**
  - 전역 변수를 덜 더럽힘
  - 클로저를 통해 함수와 변수를 지역화
  - 스크립트 문법이 더 일관성 있음
  - 명시적으로 public 메소드와 변수를 제공해 명시성을 높임
- 단점
  - **_private 메소드 접근할 방법이 없음_** (그래서 테스트 불가란 얘기를 하는데 private은 테스트 할지 안할지 고민해봐야)
  - private 메소드에 대해 함수 확장하는데 어려움이 있음
  - private 메소드를 참조하는 public 메소드를 수정하기 어려움

참고) [**즉시 실행 함수?**](https://beomy.tistory.com/9)

```
(function () {
    // statements
})()
```

- 함수를 1. 정의, 2. 변수에 함수를 저장, 3. 실행의 과정이 아닌 **_함수를 정의하자마자 바로 호출하는 함수_**
- 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다.

## 8) MVC 패턴

<aside>
💡

모델, 뷰, 컨트롤러로 이루어진 디자인 패턴

</aside>

- 모델 : 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함. 박스위치정보, 글자내용, 글자 위치, 글자 포맷 등 모든 정보를 모두 가지고 있어야하고, 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함
- 뷰 : inputbox, checkbox 등 사용자 인터페이스 요소, 모델을 기반으로 사용자가 볼 수 있는 화면. 모델이 가지고 있는 정보를 따로 저장하지 않아야하고, 변경이 일어나면 컨트롤러에 이를 전달해야함
- 컨트롤러 : 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할, 이벤트 등 메인 로직을 담당함. 모델과 뷰의 생명주기도 관리하고, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용에 대해 알려줌
- MVC 패턴을 이용한 대표적인 프레임워크 스프링
  - 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크
  - 스프링 web MVC는 @RequestParam, @RequestHeader, @PathVariable 등의 어노테이션을 기반으로 사용자의 요청 값들을 쉽게 분석하고, 어떤 요청이 유효한 요청인지 쉽게 거를 수 있다.
  - 재사용 가능한 코드, 테스트, 쉽게 리디렉션할 수 있게 하는 등의 장점이 있다.
- 장점
  - MVC 패턴의 장점은 널리 사용되고 있는 패턴이라는 점에 걸맞게 가장 단순합니다. 단순하다 보니 보편적으로 많이 사용되는 디자인패턴입니다.
- 단점
  - MVC 패턴의 단점은 View와 Model 사이의 의존성이 높다는 것입니다. View와 Model의 높은 의존성은 어플리케이션이 커질 수록 복잡하지고 유지보수가 어렵게 만들 수 있습니다.

참고) 역할을 분리하는 이유?

아키텍처와 디자인 패턴이 중요한 이유는 이렇게 **`염려의 분리(Separate of Concern)`**를 가능하게 해주는 것이라고 생각한다. 즉, 각자 역할을 나누어 관리를 함으로써, 유지 보수와 개발 효율을 향상시킬 수 있다.

## 9) MVP 패턴

<aside>
💡

MVC 패턴으로부터 파생되었으며 MVC 에서 C에 해당하는 컨트롤러가 프레젠터(presenter) 로 교체된 패턴

</aside>

- 뷰와 프레젠터는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이다.
- MVC 패턴의 단점인 View 와 Model간의 의존성을 없애줄 수 있다.
- 장점
  - MVP 패턴의 장점은 View와 Model의 의존성이 없다는 것입니다. MVP 패턴은 MVC 패턴의 단점이었던 View와 Model의 의존성을 해결하였습니다. (Presenter를 통해서만 데이터를 전달 받기 때문에..)
- 단점
  - MVC 패턴의 단점인 View와 Model 사이의 의존성은 해결되었지만, View와 Presenter 사이의 의존성이 높은 가지게 되는 단점이 있습니다. 어플리케이션이 복잡해 질 수록 View와 Presenter 사이의 의존성이 강해지는 단점이 있습니다.코드 상으로는 View-Presenter 일대일 관계로 인해, 각 View 를 위한 각 Presenter 가 필요하게된다. 이로 인해 코드의 수가 기하급수적으로 증가하게 됩니다.

## 10) MVVM 패턴

<aside>
💡

MVC 패턴의 C에 해당하는 컨트롤러가 뷰모델(View model)로 바뀐 패턴

</aside>

- 뷰모델 : 뷰를 더 추상화한 계층
- MVC 모델과의 차이점 : MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가진다
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점
- MVVM 패턴을 이용한 Vue 프레임워크
  - Vue.js는 반응형(reactivity)이 특징인 프런트엔드 프레임워크
  - watch 와 computed등으로 쉽게 반응형적인 값들을 구축가능
  - 함수를 사용하지 않고 값 대입만으로도 변수가 변경됨
  - 양방향 바인딩
  - html을 토대로 컴포넌트 구축 가능
  - 재사용 가능한 컴포넌트 기반으로 UI 구축가능
- 장점
  - MVVM 패턴은 View와 Model 사이의 의존성이 없습니다.

    - Command 패턴과 Data Binding을 사용하여 View와 View Model 사이의 의존성 또한 없앤 디자인패턴입니다. 각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있습니다.
    - 그래픽 사용자 인터페이스(GUI; Graphic User Interface)의 개발을 비즈니스 로직 또는 백-엔드 로직(모델)로부터 분리시켜서, View가 어느 특정한 모델 플랫폼에 종속되지 않도록 해준다

    ⇒ 즉, MVC PATTERN부터 초래된 문제인 View와 Model의 의존성을 해결하고,MVP 의 문제점인 View-Presenter 관계의 의존성은 데이터 바인딩과 명령을 통해 해결하게 된다.
- 단점
  - MVVM 패턴의 단점은 View Model의 설계가 쉽지 않다는 점입니다.데이터 바인딩을 도와주는 라이브러리(ex. injector)를 함께 사용하지 않으면, 많은 기반 코드를 작성해야 함.

## 11) 객체지향 프로그래밍

### [객체지향 프로그래밍 특징] - 캡상추다

### 캡슐화

encapsulation

객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

### 상속성

inheritance

상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것

코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요

### 추상화

abstraction

복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것

### 다형성

polymorphism

하나의 메서드나 클래스가 다양한 방법으로 동작하는 것 → **오버로딩, 오버라이딩**이 있음

### 오버로딩

overloading

**같은 이름을 가진 메서드를 여러 개** 두는 것

메서드의 타입, 매개변수의 유형, 개수 등으로 여러개를 둘 수 있다

컴파일 중에 발생하는 **정적 다형성**이다.

### 오버라이딩

overriding

주로 메서드 오버라이딩을 말하며 **상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것**

런타임 중에 발생하는 **동적 다형성**이다.

### [객체지향 설계원칙 SOLID]

### S 단일 책임 원칙 SRP

Single Responsibility Principle

모든 클래스는 각각 하나의 책임만 가져야하는 원칙

ex) A라는 로직이 존재한다면 어떠한 클래스는 A에 관한 클래스여야 하고 이를 수정할 때도 A와 관련된 수정이어야 한다.

### O 개방-폐쇄 원칙 OCP

Open Closed Principle

유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 하는 원칙

기존의 코드는 잘 변경하지 않으면서도 확장을 쉽게 할 수 있어야 한다.

### L 리스코프 치환 원칙 LSP

Liskov Substitution Principle

프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것

클래스는 상속되고, 부모, 자식 계층관계가 만들어지는데 이때 부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가게 만드는 것

### I 인터페이스 분리 원칙 ISP

Interface Segregation Principle

하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙

### D 의존 역전 원칙 DIP

Dependency Inversion Principle

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향 받지 않게 하는 원칙

ex) 타이어를 갈아끼울 수 있는 틀을 만들어 놓은 후 타양한 타이어를 교체할 수 있어야 한다. 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다.
