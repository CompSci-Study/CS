## 복잡도 

### 시간 복잡도 
정의 : 입력 크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간 
> 빅오 표기법 

입력 범위 N을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것, 가장 많은 영향을 끼치는 상수인자만 사용 <br>
why? : 효율적인 코드로 개선하는데 쓰이는 척도 

### 공간 복잡도 
프로그램을 실행시켰을 대 필요로하는 자원 공간의 양 

## 선형 자료 구조 
요소가 일렬로 나열되어 있는 자료 구조 
### 연결 리스트 
[특징] 
- 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화 시킨 자료 구조 => 동적 메모리 할당 <br>
- 삽입, 삭제가 빠름 : 삽입, 삭제 -> O(1) <br>
- 랜덤접근이 어려움 : 순차 탐색 -> O(N)

✔ 단일 연결 리스트 → 메모리 절약, 한 방향 이동(next) <br>
✔ 이중 연결 리스트 → 더 많은 메모리 필요, 양방향 이동 가능(next, prev) <br>
✔ 원형 이중 연결 리스트 → 양방향 순환 가능(next-헤드), 끝이 없음 (무한 반복 처리 가능)


### 배열 
같은 타입의 변수로 구성, 정해진 크기, 인접한 메모리 위치에 있는 데이터를 모아 놓은 집합, 중복 허용가능, 순서 있음

> 랜덤 접근과 순차적 접근 

[ 랜덤 접근 = 직접 접근 ] 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능 <br>
[ 순차적 접근 ] 데이터를 저장된 순서로 검색 

> 배열과 연결 리스트 비교 

[배열] 상자를 순서대로 나열 <br>
[연결리스트] 상자를 내부를 하나씩 확인

### 벡터 
동적으로 요소를 할당할 수 있는 동적 배열 (가변크기 배열) <br>
ex. Java -> ArrayList 

✔ 자동 크기 증가: 기존 크기가 꽉 차면 일정 비율(보통 2배)로 크기를 증가<br>
✔ 인덱스 접근 O(1): 배열처럼 인덱스를 통해 빠르게 접근 가능<br>
✔ 삽입/삭제 O(n): 중간에 삽입/삭제 시 데이터 이동 필요<br>

|특성	|배열 (Array)	|연결 리스트 (Linked List)|벡터 (Vector)	|
|--|--|--|--|
|메모리 할당	|고정 크기 (연속된 메모리)|	동적 크기 (노드마다 메모리 할당)|자동 크기 조정 (배수 증가)	|
|접근 속도	|O(1) (인덱스 접근)	|O(n) (순차 탐색 필요)|O(1) (인덱스 접근)|
|삽입/삭제 속도|	O(n) (중간 삽입/삭제 시 데이터 이동 필요)|	O(1) (포인터 변경)|O(n) (중간 삽입/삭제 시 데이터 이동 필요)|
|메모리 사용량	|효율적 (데이터만 저장)	|높음 (포인터 추가 필요)|추가 메모리 필요 (리사이징 시 여유 공간 할당)|
|순차적 저장|	연속된 메모리 공간	|분산된 메모리 공간|--|
|활용 예시	|고정 크기의 데이터 저장 (ex: 배열 기반 리스트, 행렬)|동적 데이터 관리 (ex: 스택, 큐, 그래프)|동적 배열 (ex: 동적 리스트, 스택)	|

### 스택 

가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질 (LIFO, Last In First Out) <br>

### 큐 
먼저 집어넣은 데이터가 먼저 나오는 성질 (FIFO, First In First Out) <br>

|구조|	스택(Stack)|	큐(Queue)|
|--|--|--|
|삽입(Enqueue/Push)	|O(1) (맨 위에 추가)	|O(1) (맨 뒤에 추가)|
|삭제(Dequeue/Pop)|	O(1) (맨 위에서 제거)	|O(1) (맨 앞에서 제거)|
|데이터 구조	|LIFO (Last In, First Out)	|FIFO (First In, First Out)|
|삽입/삭제 방식	|push(값) → pop() (맨 위)|	enqueue(값) → dequeue() (맨 앞)|
|사용 예시	|재귀 호출, 실행 취소(Undo), DFS|	프린터 대기열, 프로세스 스케줄링, BFS|

## 비선형 자료 구조 
일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조 

### 그래프 
정점과 간선으로 이루어진 자료 구조 

> 정점과 간선 

✔ 정점(Vertex, 노드) → 데이터를 담고 있는 점 <br>
✔ 간선(Edge) → 정점 간의 연결선

**가중치** : 간선과 정점 사이에 드는 비용 

### 트리 

> 트리의 특징 

그래프 중 하나, 정점과 간선으로 이루어짐, 계층적 데이터의 집합 <br>

> 트리의 구성 

- 루트 : 가장 위에 있는 노드 
- 내부 : 루트 노드와 내부 노드 사이에 있는 노드 
- 리프 : 자식 노드가 없는 노드 

> 트리의 높이와 레벨 

- 깊이 : 각 노드 마다 다름, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리 
- 높이 : 루트 노드부터 리프 노드까지 가장 긴 거리
- 레벨 : 깊이
- 서브 트리 : 트리 내의 하위 집합 혹은 부분 집합 

> 이진 트리 

자식의 노드 수가 두 개 이하인 트리 
- 정이진 트리 : 자식 노드가 0 또는 두 개 
- 완전 이진 트리 : 왼쪽에서부터 채워짐, 마지막 레벨 제외하곤 모든 레벨이 채워짐, 마지막 레벨의 경우 왼쪽부터 채워짐 
- 변질 이진 트리 : 자식노드 하나 
- 포화 이진 트리 : 모든 노드가 꽉 차 있음
- 균형 이진 트리 : 왼쪽과 오른쪽 노드의 높이 차이가 1 이하

> 이진 탐색 트리 BST

오른쪽 하위 : 노드 값 보다 큰 값 <br>
왼쪽 하위: 노드 값 보다 작은 값 <br>
최악의 경우일 때(선형) 시간 복잡도 -> O(N)

> AVL 트리 

선형 적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진트리 <br>
두 자식 서브트리의 높이는 항상 최대 1만큼 차이 
시간 복잡도 -> O(logN)

> 레드 블랙 트리 

균형 이진 탐색 트리  <br>
시간 복잡도 -> 탐색, 삽입, 삭제 O(logN) 


### 힙 
완전 이진 트리 기반의 자료 구조 
- 최대힙 : 루트 노드에 있는 키는 모든 자식 키값 중 가장 커야 함
- 최소힙 : 루트 노드에 있는 키는 모든 자식 키값 중 가장 작아야 함

> 최대힙의 삽입 

새로운 요소가 들어오면, 우선 새로운 노드를 힙의 마지막 노드에 이어서 삽입. 부모 노드들과 크기를 비교하며 교환해서 힙의 성질 만족.

> 최대힙의 삭제 

루트노드가 최댓값이므로 루트 노그가 삭재. 마지막 노드와 루트노드를 스왑하여 다시 스왑 과정을 거친 후 재구성 

### 우선순위 큐 

**힙** 기반<br>
대기열에서 우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공 

### 맵 

특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조 <br>
레드 블랙 트리 자료 구조를 기반으로 형성, 삽입 시 자동 정렬 <br>
해시 테이블 구현할 때 사용, 정렬을 보장하는 맵과, 보장하지 않는 맵이 있음 

### 셋 

특정 순서에 따라 고유한 요소를 저장하는 컨테이너, 중복되는 요소는 없고 희소한 값만 저장 

### 해시 테이블 

정렬을 보장하지 않는 맵 unordered_map으로 구현 <br>
키(Key)를 해시 함수(Hash Function)를 통해 고정된 크기의 해시 값으로 변환하여 저장

